---
title: WriterT - arrow-data
---

[arrow-data](../../index.html) / [arrow.data](../index.html) / [WriterT](./index.html)

# WriterT

`@higherkind data class WriterT<F, W, A> : `[`WriterTOf`](../-writer-t-of.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`A`](index.html#A)`>, `[`WriterTKindedJ`](../-writer-t-kinded-j.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`A`](index.html#A)`>`

### Constructors

| [&lt;init&gt;](-init-.html) | `WriterT(value: Kind<`[`F`](index.html#F)`, Tuple2<`[`W`](index.html#W)`, `[`A`](index.html#A)`>>)` |

### Properties

| [value](value.html) | `val value: Kind<`[`F`](index.html#F)`, Tuple2<`[`W`](index.html#W)`, `[`A`](index.html#A)`>>` |

### Functions

| [ap](ap.html) | `fun <B> ap(MF: Monad<`[`F`](index.html#F)`>, SG: Semigroup<`[`W`](index.html#W)`>, ff: `[`WriterTOf`](../-writer-t-of.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, (`[`A`](index.html#A)`) -> `[`B`](ap.html#B)`>): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`B`](ap.html#B)`>` |
| [bimap](bimap.html) | `fun <C, U> bimap(MF: Monad<`[`F`](index.html#F)`>, g: (`[`W`](index.html#W)`) -> `[`U`](bimap.html#U)`, f: (`[`A`](index.html#A)`) -> `[`C`](bimap.html#C)`): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`U`](bimap.html#U)`, `[`C`](bimap.html#C)`>` |
| [combineK](combine-k.html) | `fun combineK(SF: SemigroupK<`[`F`](index.html#F)`>, y: `[`WriterTOf`](../-writer-t-of.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`A`](index.html#A)`>): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`A`](index.html#A)`>` |
| [content](content.html) | `fun content(FF: Functor<`[`F`](index.html#F)`>): Kind<`[`F`](index.html#F)`, `[`A`](index.html#A)`>` |
| [flatMap](flat-map.html) | `fun <B> flatMap(MF: Monad<`[`F`](index.html#F)`>, SG: Semigroup<`[`W`](index.html#W)`>, f: (`[`A`](index.html#A)`) -> `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`B`](flat-map.html#B)`>): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`B`](flat-map.html#B)`>` |
| [liftF](lift-f.html) | `fun <B> liftF(AF: Applicative<`[`F`](index.html#F)`>, fa: Kind<`[`F`](index.html#F)`, `[`B`](lift-f.html#B)`>): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`B`](lift-f.html#B)`>` |
| [listen](listen.html) | `fun listen(MF: Monad<`[`F`](index.html#F)`>): Kind<`[`WriterTPartialOf`](../-writer-t-partial-of.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`>, Tuple2<`[`W`](index.html#W)`, `[`A`](index.html#A)`>>` |
| [map](map.html) | `fun <B> map(FF: Functor<`[`F`](index.html#F)`>, f: (`[`A`](index.html#A)`) -> `[`B`](map.html#B)`): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`B`](map.html#B)`>` |
| [mapAcc](map-acc.html) | `fun <U> mapAcc(MF: Monad<`[`F`](index.html#F)`>, f: (`[`W`](index.html#W)`) -> `[`U`](map-acc.html#U)`): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`U`](map-acc.html#U)`, `[`A`](index.html#A)`>` |
| [reset](reset.html) | `fun reset(MF: Monad<`[`F`](index.html#F)`>, MM: Monoid<`[`W`](index.html#W)`>): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`A`](index.html#A)`>` |
| [semiflatMap](semiflat-map.html) | `fun <C> semiflatMap(MF: Monad<`[`F`](index.html#F)`>, SG: Semigroup<`[`W`](index.html#W)`>, f: (`[`A`](index.html#A)`) -> Kind<`[`F`](index.html#F)`, `[`C`](semiflat-map.html#C)`>): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`C`](semiflat-map.html#C)`>` |
| [subflatMap](subflat-map.html) | `fun <B> subflatMap(MF: Monad<`[`F`](index.html#F)`>, f: (`[`A`](index.html#A)`) -> Tuple2<`[`W`](index.html#W)`, `[`B`](subflat-map.html#B)`>): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`B`](subflat-map.html#B)`>` |
| [swap](swap.html) | `fun swap(MF: Monad<`[`F`](index.html#F)`>): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`A`](index.html#A)`, `[`W`](index.html#W)`>` |
| [tell](tell.html) | `fun tell(MF: Monad<`[`F`](index.html#F)`>, SG: Semigroup<`[`W`](index.html#W)`>, w: `[`W`](index.html#W)`): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`W`](index.html#W)`, `[`A`](index.html#A)`>` |
| [transform](transform.html) | `fun <B, U> transform(MF: Monad<`[`F`](index.html#F)`>, f: (Tuple2<`[`W`](index.html#W)`, `[`A`](index.html#A)`>) -> Tuple2<`[`U`](transform.html#U)`, `[`B`](transform.html#B)`>): `[`WriterT`](./index.html)`<`[`F`](index.html#F)`, `[`U`](transform.html#U)`, `[`B`](transform.html#B)`>` |
| [write](write.html) | `fun write(FF: Functor<`[`F`](index.html#F)`>): Kind<`[`F`](index.html#F)`, `[`W`](index.html#W)`>` |

### Companion Object Functions

| [both](both.html) | `fun <F, W, A> both(MF: Monad<`[`F`](both.html#F)`>, w: `[`W`](both.html#W)`, a: `[`A`](both.html#A)`): `[`WriterT`](./index.html)`<`[`F`](both.html#F)`, `[`W`](both.html#W)`, `[`A`](both.html#A)`>` |
| [empty](empty.html) | `fun <F, W, A> empty(MMF: MonoidK<`[`F`](empty.html#F)`>): `[`WriterTOf`](../-writer-t-of.html)`<`[`F`](empty.html#F)`, `[`W`](empty.html#W)`, `[`A`](empty.html#A)`>` |
| [fromTuple](from-tuple.html) | `fun <F, W, A> fromTuple(MF: Monad<`[`F`](from-tuple.html#F)`>, z: Tuple2<`[`W`](from-tuple.html#W)`, `[`A`](from-tuple.html#A)`>): `[`WriterT`](./index.html)`<`[`F`](from-tuple.html#F)`, `[`W`](from-tuple.html#W)`, `[`A`](from-tuple.html#A)`>` |
| [invoke](invoke.html) | `operator fun <F, W, A> invoke(value: Kind<`[`F`](invoke.html#F)`, Tuple2<`[`W`](invoke.html#W)`, `[`A`](invoke.html#A)`>>): `[`WriterT`](./index.html)`<`[`F`](invoke.html#F)`, `[`W`](invoke.html#W)`, `[`A`](invoke.html#A)`>` |
| [just](just.html) | `fun <F, W, A> just(AF: Applicative<`[`F`](just.html#F)`>, MM: Monoid<`[`W`](just.html#W)`>, a: `[`A`](just.html#A)`): `[`WriterT`](./index.html)`<`[`F`](just.html#F)`, `[`W`](just.html#W)`, `[`A`](just.html#A)`>` |
| [pass](pass.html) | `fun <F, W, A> pass(MF: Monad<`[`F`](pass.html#F)`>, fa: Kind<`[`WriterTPartialOf`](../-writer-t-partial-of.html)`<`[`F`](pass.html#F)`, `[`W`](pass.html#W)`>, Tuple2<(`[`W`](pass.html#W)`) -> `[`W`](pass.html#W)`, `[`A`](pass.html#A)`>>): `[`WriterT`](./index.html)`<`[`F`](pass.html#F)`, `[`W`](pass.html#W)`, `[`A`](pass.html#A)`>` |
| [put](put.html) | `fun <F, W, A> put(AF: Applicative<`[`F`](put.html#F)`>, a: `[`A`](put.html#A)`, w: `[`W`](put.html#W)`): `[`WriterT`](./index.html)`<`[`F`](put.html#F)`, `[`W`](put.html#W)`, `[`A`](put.html#A)`>` |
| [put2](put2.html) | `fun <F, W, A> put2(AF: Applicative<`[`F`](put2.html#F)`>, a: `[`A`](put2.html#A)`, w: `[`W`](put2.html#W)`): `[`WriterT`](./index.html)`<`[`F`](put2.html#F)`, `[`W`](put2.html#W)`, `[`A`](put2.html#A)`>` |
| [putT](put-t.html) | `fun <F, W, A> putT(FF: Functor<`[`F`](put-t.html#F)`>, vf: Kind<`[`F`](put-t.html#F)`, `[`A`](put-t.html#A)`>, w: `[`W`](put-t.html#W)`): `[`WriterT`](./index.html)`<`[`F`](put-t.html#F)`, `[`W`](put-t.html#W)`, `[`A`](put-t.html#A)`>` |
| [putT2](put-t2.html) | `fun <F, W, A> putT2(FF: Functor<`[`F`](put-t2.html#F)`>, vf: Kind<`[`F`](put-t2.html#F)`, `[`A`](put-t2.html#A)`>, w: `[`W`](put-t2.html#W)`): `[`WriterT`](./index.html)`<`[`F`](put-t2.html#F)`, `[`W`](put-t2.html#W)`, `[`A`](put-t2.html#A)`>` |
| [tailRecM](tail-rec-m.html) | `fun <F, W, A, B> tailRecM(MF: Monad<`[`F`](tail-rec-m.html#F)`>, a: `[`A`](tail-rec-m.html#A)`, f: (`[`A`](tail-rec-m.html#A)`) -> Kind<`[`WriterTPartialOf`](../-writer-t-partial-of.html)`<`[`F`](tail-rec-m.html#F)`, `[`W`](tail-rec-m.html#W)`>, Either<`[`A`](tail-rec-m.html#A)`, `[`B`](tail-rec-m.html#B)`>>): `[`WriterT`](./index.html)`<`[`F`](tail-rec-m.html#F)`, `[`W`](tail-rec-m.html#W)`, `[`B`](tail-rec-m.html#B)`>` |
| [tell](tell.html) | `fun <F, W> tell(AF: Applicative<`[`F`](tell.html#F)`>, l: `[`W`](tell.html#W)`): `[`WriterT`](./index.html)`<`[`F`](tell.html#F)`, `[`W`](tell.html#W)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>` |
| [tell2](tell2.html) | `fun <F, W> tell2(AF: Applicative<`[`F`](tell2.html#F)`>, l: `[`W`](tell2.html#W)`): `[`WriterT`](./index.html)`<`[`F`](tell2.html#F)`, `[`W`](tell2.html#W)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>` |
| [value](value.html) | `fun <F, W, A> value(AF: Applicative<`[`F`](value.html#F)`>, monoidW: Monoid<`[`W`](value.html#W)`>, v: `[`A`](value.html#A)`): `[`WriterT`](./index.html)`<`[`F`](value.html#F)`, `[`W`](value.html#W)`, `[`A`](value.html#A)`>` |
| [valueT](value-t.html) | `fun <F, W, A> valueT(AF: Applicative<`[`F`](value-t.html#F)`>, monoidW: Monoid<`[`W`](value-t.html#W)`>, vf: Kind<`[`F`](value-t.html#F)`, `[`A`](value-t.html#A)`>): `[`WriterT`](./index.html)`<`[`F`](value-t.html#F)`, `[`W`](value-t.html#W)`, `[`A`](value-t.html#A)`>` |

### Extension Functions

| [ap](../arrow.-kind/ap.html) | `fun <E, A, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/ap.html#E)`, `[`A`](../arrow.-kind/ap.html#A)`>.ap(SE: Semigroup<`[`E`](../arrow.-kind/ap.html#E)`>, f: `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/ap.html#E)`, (`[`A`](../arrow.-kind/ap.html#A)`) -> `[`B`](../arrow.-kind/ap.html#B)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/ap.html#E)`, `[`B`](../arrow.-kind/ap.html#B)`>`<br>From Apply: if both the function and this value are Valid, apply the function |
| [combine](../arrow.-kind/combine.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>.combine(SE: Semigroup<`[`E`](../arrow.-kind/combine.html#E)`>, SA: Semigroup<`[`A`](../arrow.-kind/combine.html#A)`>, y: `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>` |
| [combineK](../arrow.-kind/combine-k.html) | `fun <A> `[`ListKOf`](../-list-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`ListKOf`](../-list-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`ListK`](../-list-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`NonEmptyListOf`](../-non-empty-list-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`NonEmptyListOf`](../-non-empty-list-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`NonEmptyList`](../-non-empty-list/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`SequenceK`](../-sequence-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`SetKOf`](../-set-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`SetKOf`](../-set-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`SetK`](../-set-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(SE: Semigroup<`[`E`](../arrow.-kind/combine-k.html#E)`>, y: `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>` |
| [findValid](../arrow.-kind/find-valid.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>.findValid(SE: Semigroup<`[`E`](../arrow.-kind/find-valid.html#E)`>, that: () -> `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>`<br>If `this` is valid return `this`, otherwise if `that` is valid return `that`, otherwise combine the failures. This is similar to [orElse](../arrow.-kind/or-else.html) except that here failures are accumulated. |
| [getOrElse](../arrow.-kind/get-or-else.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/get-or-else.html#E)`, `[`B`](../arrow.-kind/get-or-else.html#B)`>.getOrElse(default: () -> `[`B`](../arrow.-kind/get-or-else.html#B)`): `[`B`](../arrow.-kind/get-or-else.html#B)<br>Return the Valid value, or the default if Invalid |
| [handleLeftWith](../arrow.-kind/handle-left-with.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>.handleLeftWith(f: (`[`E`](../arrow.-kind/handle-left-with.html#E)`) -> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>` |
| [mapFilter](../arrow.-kind/map-filter.html) | `fun <F, A, B> `[`OptionTOf`](../-option-t-of.html)`<`[`F`](../arrow.-kind/map-filter.html#F)`, `[`A`](../arrow.-kind/map-filter.html#A)`>.mapFilter(FF: Functor<`[`F`](../arrow.-kind/map-filter.html#F)`>, f: (`[`A`](../arrow.-kind/map-filter.html#A)`) -> Option<`[`B`](../arrow.-kind/map-filter.html#B)`>): `[`OptionT`](../-option-t/index.html)`<`[`F`](../arrow.-kind/map-filter.html#F)`, `[`B`](../arrow.-kind/map-filter.html#B)`>` |
| [orElse](../arrow.-kind/or-else.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>.orElse(default: () -> `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>`<br>Return this if it is Valid, or else fall back to the given default. The functionality is similar to that of [findValid](../arrow.-kind/find-valid.html) except for failure accumulation, where here only the error on the right is preserved and the error on the left is ignored. |
| [orNull](../arrow.-kind/or-null.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/or-null.html#E)`, `[`B`](../arrow.-kind/or-null.html#B)`>.orNull(): `[`B`](../arrow.-kind/or-null.html#B)`?`<br>Return the Valid value, or null if Invalid |
| [runM](../arrow.-kind/run-m.html) | `fun <F, S, A> `[`StateTOf`](../-state-t-of.html)`<`[`F`](../arrow.-kind/run-m.html#F)`, `[`S`](../arrow.-kind/run-m.html#S)`, `[`A`](../arrow.-kind/run-m.html#A)`>.runM(MF: Monad<`[`F`](../arrow.-kind/run-m.html#F)`>, initial: `[`S`](../arrow.-kind/run-m.html#S)`): Kind<`[`F`](../arrow.-kind/run-m.html#F)`, Tuple2<`[`S`](../arrow.-kind/run-m.html#S)`, `[`A`](../arrow.-kind/run-m.html#A)`>>`<br>Run the stateful computation within the context `F`. |
| [stateT](../arrow.-kind/state-t.html) | `fun <F, S, A> `[`StateTFunOf`](../-state-t-fun-of.html)`<`[`F`](../arrow.-kind/state-t.html#F)`, `[`S`](../arrow.-kind/state-t.html#S)`, `[`A`](../arrow.-kind/state-t.html#A)`>.stateT(): `[`StateT`](../-state-t/index.html)`<`[`F`](../arrow.-kind/state-t.html#F)`, `[`S`](../arrow.-kind/state-t.html#S)`, `[`A`](../arrow.-kind/state-t.html#A)`>`<br>Wrap the function with [StateT](../-state-t/index.html). |
| [toIor](../arrow.-kind/to-ior.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/to-ior.html#E)`, `[`A`](../arrow.-kind/to-ior.html#A)`>.toIor(): `[`Ior`](../-ior/index.html)`<`[`E`](../arrow.-kind/to-ior.html#E)`, `[`A`](../arrow.-kind/to-ior.html#A)`>`<br>Converts the value to an Ior&lt;E, A&gt; |
| [toList](../arrow.-kind/to-list.html) | `fun <A> `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/to-list.html#A)`>.toList(): `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`A`](../arrow.-kind/to-list.html#A)`>` |
| [traverse](../arrow.-kind/traverse.html) | `fun <G, E, A, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/traverse.html#E)`, `[`A`](../arrow.-kind/traverse.html#A)`>.traverse(GA: Applicative<`[`G`](../arrow.-kind/traverse.html#G)`>, f: (`[`A`](../arrow.-kind/traverse.html#A)`) -> Kind<`[`G`](../arrow.-kind/traverse.html#G)`, `[`B`](../arrow.-kind/traverse.html#B)`>): Kind<`[`G`](../arrow.-kind/traverse.html#G)`, `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/traverse.html#E)`, `[`B`](../arrow.-kind/traverse.html#B)`>>` |
| [valueOr](../arrow.-kind/value-or.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/value-or.html#E)`, `[`B`](../arrow.-kind/value-or.html#B)`>.valueOr(f: (`[`E`](../arrow.-kind/value-or.html#E)`) -> `[`B`](../arrow.-kind/value-or.html#B)`): `[`B`](../arrow.-kind/value-or.html#B)<br>Return the Valid value, or the result of f if Invalid |

