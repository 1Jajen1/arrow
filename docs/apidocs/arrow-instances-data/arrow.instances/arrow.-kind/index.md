---
title: arrow.instances.arrow.Kind - arrow-instances-data
---

[arrow-instances-data](../../index.html) / [arrow.instances](../index.html) / [arrow.Kind](./index.html)

### Extensions for arrow.Kind

| [foldLeft](fold-left.html) | `fun <F, A, B, C> EitherTOf<`[`F`](fold-left.html#F)`, `[`A`](fold-left.html#A)`, `[`B`](fold-left.html#B)`>.foldLeft(FF: Foldable<`[`F`](fold-left.html#F)`>, b: `[`C`](fold-left.html#C)`, f: (`[`C`](fold-left.html#C)`, `[`B`](fold-left.html#B)`) -> `[`C`](fold-left.html#C)`): `[`C`](fold-left.html#C)<br>`fun <F, A, B> OptionTOf<`[`F`](fold-left.html#F)`, `[`A`](fold-left.html#A)`>.foldLeft(FF: Foldable<`[`F`](fold-left.html#F)`>, b: `[`B`](fold-left.html#B)`, f: (`[`B`](fold-left.html#B)`, `[`A`](fold-left.html#A)`) -> `[`B`](fold-left.html#B)`): `[`B`](fold-left.html#B) |
| [foldRight](fold-right.html) | `fun <F, A, B, C> EitherTOf<`[`F`](fold-right.html#F)`, `[`A`](fold-right.html#A)`, `[`B`](fold-right.html#B)`>.foldRight(FF: Foldable<`[`F`](fold-right.html#F)`>, lb: Eval<`[`C`](fold-right.html#C)`>, f: (`[`B`](fold-right.html#B)`, Eval<`[`C`](fold-right.html#C)`>) -> Eval<`[`C`](fold-right.html#C)`>): Eval<`[`C`](fold-right.html#C)`>`<br>`fun <F, A, B> OptionTOf<`[`F`](fold-right.html#F)`, `[`A`](fold-right.html#A)`>.foldRight(FF: Foldable<`[`F`](fold-right.html#F)`>, lb: Eval<`[`B`](fold-right.html#B)`>, f: (`[`A`](fold-right.html#A)`, Eval<`[`B`](fold-right.html#B)`>) -> Eval<`[`B`](fold-right.html#B)`>): Eval<`[`B`](fold-right.html#B)`>` |
| [sequence](sequence.html) | `fun <F, G, A, B> EitherTOf<`[`F`](sequence.html#F)`, `[`A`](sequence.html#A)`, Kind<`[`G`](sequence.html#G)`, `[`B`](sequence.html#B)`>>.sequence(FF: Traverse<`[`F`](sequence.html#F)`>, GA: Applicative<`[`G`](sequence.html#G)`>): Kind<`[`G`](sequence.html#G)`, EitherT<`[`F`](sequence.html#F)`, `[`A`](sequence.html#A)`, `[`B`](sequence.html#B)`>>`<br>`fun <F, G, A> OptionTOf<`[`F`](sequence.html#F)`, Kind<`[`G`](sequence.html#G)`, `[`A`](sequence.html#A)`>>.sequence(FF: Traverse<`[`F`](sequence.html#F)`>, GA: Applicative<`[`G`](sequence.html#G)`>): Kind<`[`G`](sequence.html#G)`, OptionT<`[`F`](sequence.html#F)`, `[`A`](sequence.html#A)`>>` |
| [traverse](traverse.html) | `fun <F, A, B, G, C> EitherTOf<`[`F`](traverse.html#F)`, `[`A`](traverse.html#A)`, `[`B`](traverse.html#B)`>.traverse(FF: Traverse<`[`F`](traverse.html#F)`>, GA: Applicative<`[`G`](traverse.html#G)`>, f: (`[`B`](traverse.html#B)`) -> Kind<`[`G`](traverse.html#G)`, `[`C`](traverse.html#C)`>): Kind<`[`G`](traverse.html#G)`, EitherT<`[`F`](traverse.html#F)`, `[`A`](traverse.html#A)`, `[`C`](traverse.html#C)`>>`<br>`fun <F, G, A, B> OptionTOf<`[`F`](traverse.html#F)`, `[`A`](traverse.html#A)`>.traverse(FF: Traverse<`[`F`](traverse.html#F)`>, GA: Applicative<`[`G`](traverse.html#G)`>, f: (`[`A`](traverse.html#A)`) -> Kind<`[`G`](traverse.html#G)`, `[`B`](traverse.html#B)`>): Kind<`[`G`](traverse.html#G)`, OptionT<`[`F`](traverse.html#F)`, `[`B`](traverse.html#B)`>>` |

