---
title: arrow.instances.coproduct.foldable.arrow.Kind - arrow-instances-data
---

[arrow-instances-data](../../index.html) / [arrow.instances.coproduct.foldable](../index.html) / [arrow.Kind](./index.html)

### Extensions for arrow.Kind

| [combineAll](combine-all.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](combine-all.html#F)`>, `[`G`](combine-all.html#G)`>, `[`A`](combine-all.html#A)`>.combineAll(arg1: Monoid<`[`A`](combine-all.html#A)`>, FF: Foldable<`[`F`](combine-all.html#F)`>, FG: Foldable<`[`G`](combine-all.html#G)`>): `[`A`](combine-all.html#A) |
| [exists](exists.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](exists.html#F)`>, `[`G`](exists.html#G)`>, `[`A`](exists.html#A)`>.exists(arg1: (`[`A`](exists.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`, FF: Foldable<`[`F`](exists.html#F)`>, FG: Foldable<`[`G`](exists.html#G)`>): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [find](find.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](find.html#F)`>, `[`G`](find.html#G)`>, `[`A`](find.html#A)`>.find(arg1: (`[`A`](find.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`, FF: Foldable<`[`F`](find.html#F)`>, FG: Foldable<`[`G`](find.html#G)`>): Option<`[`A`](find.html#A)`>` |
| [fold](fold.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](fold.html#F)`>, `[`G`](fold.html#G)`>, `[`A`](fold.html#A)`>.fold(arg1: Monoid<`[`A`](fold.html#A)`>, FF: Foldable<`[`F`](fold.html#F)`>, FG: Foldable<`[`G`](fold.html#G)`>): `[`A`](fold.html#A) |
| [foldLeft](fold-left.html) | `fun <F, G, A, B> Kind<Kind<Kind<ForCoproduct, `[`F`](fold-left.html#F)`>, `[`G`](fold-left.html#G)`>, `[`A`](fold-left.html#A)`>.foldLeft(arg1: `[`B`](fold-left.html#B)`, arg2: (`[`B`](fold-left.html#B)`, `[`A`](fold-left.html#A)`) -> `[`B`](fold-left.html#B)`, FF: Foldable<`[`F`](fold-left.html#F)`>, FG: Foldable<`[`G`](fold-left.html#G)`>): `[`B`](fold-left.html#B) |
| [foldM](fold-m.html) | `fun <F, G, A, B> Kind<Kind<Kind<ForCoproduct, `[`F`](fold-m.html#F)`>, `[`G`](fold-m.html#G)`>, `[`A`](fold-m.html#A)`>.foldM(arg1: Monad<`[`G`](fold-m.html#G)`>, arg2: `[`B`](fold-m.html#B)`, arg3: (`[`B`](fold-m.html#B)`, `[`A`](fold-m.html#A)`) -> Kind<`[`G`](fold-m.html#G)`, `[`B`](fold-m.html#B)`>, FF: Foldable<`[`F`](fold-m.html#F)`>, FG: Foldable<`[`G`](fold-m.html#G)`>): Kind<`[`G`](fold-m.html#G)`, `[`B`](fold-m.html#B)`>` |
| [foldMap](fold-map.html) | `fun <F, G, A, B> Kind<Kind<Kind<ForCoproduct, `[`F`](fold-map.html#F)`>, `[`G`](fold-map.html#G)`>, `[`A`](fold-map.html#A)`>.foldMap(arg1: Monoid<`[`B`](fold-map.html#B)`>, arg2: (`[`A`](fold-map.html#A)`) -> `[`B`](fold-map.html#B)`, FF: Foldable<`[`F`](fold-map.html#F)`>, FG: Foldable<`[`G`](fold-map.html#G)`>): `[`B`](fold-map.html#B) |
| [foldMapM](fold-map-m.html) | `fun <F, G, A, B, MA : Monad<`[`G`](fold-map-m.html#G)`>, MO : Monoid<`[`B`](fold-map-m.html#B)`>> Kind<Kind<Kind<ForCoproduct, `[`F`](fold-map-m.html#F)`>, `[`G`](fold-map-m.html#G)`>, `[`A`](fold-map-m.html#A)`>.foldMapM(arg1: `[`MA`](fold-map-m.html#MA)`, arg2: `[`MO`](fold-map-m.html#MO)`, arg3: (`[`A`](fold-map-m.html#A)`) -> Kind<`[`G`](fold-map-m.html#G)`, `[`B`](fold-map-m.html#B)`>, FF: Foldable<`[`F`](fold-map-m.html#F)`>, FG: Foldable<`[`G`](fold-map-m.html#G)`>): Kind<`[`G`](fold-map-m.html#G)`, `[`B`](fold-map-m.html#B)`>` |
| [foldRight](fold-right.html) | `fun <F, G, A, B> Kind<Kind<Kind<ForCoproduct, `[`F`](fold-right.html#F)`>, `[`G`](fold-right.html#G)`>, `[`A`](fold-right.html#A)`>.foldRight(arg1: Eval<`[`B`](fold-right.html#B)`>, arg2: (`[`A`](fold-right.html#A)`, Eval<`[`B`](fold-right.html#B)`>) -> Eval<`[`B`](fold-right.html#B)`>, FF: Foldable<`[`F`](fold-right.html#F)`>, FG: Foldable<`[`G`](fold-right.html#G)`>): Eval<`[`B`](fold-right.html#B)`>` |
| [forAll](for-all.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](for-all.html#F)`>, `[`G`](for-all.html#G)`>, `[`A`](for-all.html#A)`>.forAll(arg1: (`[`A`](for-all.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`, FF: Foldable<`[`F`](for-all.html#F)`>, FG: Foldable<`[`G`](for-all.html#G)`>): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [get](get.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](get.html#F)`>, `[`G`](get.html#G)`>, `[`A`](get.html#A)`>.get(arg1: Monad<Kind<ForEither, `[`A`](get.html#A)`>>, arg2: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, FF: Foldable<`[`F`](get.html#F)`>, FG: Foldable<`[`G`](get.html#G)`>): Option<`[`A`](get.html#A)`>` |
| [isEmpty](is-empty.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](is-empty.html#F)`>, `[`G`](is-empty.html#G)`>, `[`A`](is-empty.html#A)`>.isEmpty(FF: Foldable<`[`F`](is-empty.html#F)`>, FG: Foldable<`[`G`](is-empty.html#G)`>): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [nonEmpty](non-empty.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](non-empty.html#F)`>, `[`G`](non-empty.html#G)`>, `[`A`](non-empty.html#A)`>.nonEmpty(FF: Foldable<`[`F`](non-empty.html#F)`>, FG: Foldable<`[`G`](non-empty.html#G)`>): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [reduceLeftOption](reduce-left-option.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](reduce-left-option.html#F)`>, `[`G`](reduce-left-option.html#G)`>, `[`A`](reduce-left-option.html#A)`>.reduceLeftOption(arg1: (`[`A`](reduce-left-option.html#A)`, `[`A`](reduce-left-option.html#A)`) -> `[`A`](reduce-left-option.html#A)`, FF: Foldable<`[`F`](reduce-left-option.html#F)`>, FG: Foldable<`[`G`](reduce-left-option.html#G)`>): Option<`[`A`](reduce-left-option.html#A)`>` |
| [reduceLeftToOption](reduce-left-to-option.html) | `fun <F, G, A, B> Kind<Kind<Kind<ForCoproduct, `[`F`](reduce-left-to-option.html#F)`>, `[`G`](reduce-left-to-option.html#G)`>, `[`A`](reduce-left-to-option.html#A)`>.reduceLeftToOption(arg1: (`[`A`](reduce-left-to-option.html#A)`) -> `[`B`](reduce-left-to-option.html#B)`, arg2: (`[`B`](reduce-left-to-option.html#B)`, `[`A`](reduce-left-to-option.html#A)`) -> `[`B`](reduce-left-to-option.html#B)`, FF: Foldable<`[`F`](reduce-left-to-option.html#F)`>, FG: Foldable<`[`G`](reduce-left-to-option.html#G)`>): Option<`[`B`](reduce-left-to-option.html#B)`>` |
| [reduceRightOption](reduce-right-option.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](reduce-right-option.html#F)`>, `[`G`](reduce-right-option.html#G)`>, `[`A`](reduce-right-option.html#A)`>.reduceRightOption(arg1: (`[`A`](reduce-right-option.html#A)`, Eval<`[`A`](reduce-right-option.html#A)`>) -> Eval<`[`A`](reduce-right-option.html#A)`>, FF: Foldable<`[`F`](reduce-right-option.html#F)`>, FG: Foldable<`[`G`](reduce-right-option.html#G)`>): Eval<Option<`[`A`](reduce-right-option.html#A)`>>` |
| [reduceRightToOption](reduce-right-to-option.html) | `fun <F, G, A, B> Kind<Kind<Kind<ForCoproduct, `[`F`](reduce-right-to-option.html#F)`>, `[`G`](reduce-right-to-option.html#G)`>, `[`A`](reduce-right-to-option.html#A)`>.reduceRightToOption(arg1: (`[`A`](reduce-right-to-option.html#A)`) -> `[`B`](reduce-right-to-option.html#B)`, arg2: (`[`A`](reduce-right-to-option.html#A)`, Eval<`[`B`](reduce-right-to-option.html#B)`>) -> Eval<`[`B`](reduce-right-to-option.html#B)`>, FF: Foldable<`[`F`](reduce-right-to-option.html#F)`>, FG: Foldable<`[`G`](reduce-right-to-option.html#G)`>): Eval<Option<`[`B`](reduce-right-to-option.html#B)`>>` |
| [sequence_](sequence_.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](sequence_.html#F)`>, `[`G`](sequence_.html#G)`>, Kind<`[`G`](sequence_.html#G)`, `[`A`](sequence_.html#A)`>>.sequence_(arg1: Applicative<`[`G`](sequence_.html#G)`>, FF: Foldable<`[`F`](sequence_.html#F)`>, FG: Foldable<`[`G`](sequence_.html#G)`>): Kind<`[`G`](sequence_.html#G)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>` |
| [size](size.html) | `fun <F, G, A> Kind<Kind<Kind<ForCoproduct, `[`F`](size.html#F)`>, `[`G`](size.html#G)`>, `[`A`](size.html#A)`>.size(arg1: Monoid<`[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`>, FF: Foldable<`[`F`](size.html#F)`>, FG: Foldable<`[`G`](size.html#G)`>): `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
| [traverse_](traverse_.html) | `fun <F, G, A, B> Kind<Kind<Kind<ForCoproduct, `[`F`](traverse_.html#F)`>, `[`G`](traverse_.html#G)`>, `[`A`](traverse_.html#A)`>.traverse_(arg1: Applicative<`[`G`](traverse_.html#G)`>, arg2: (`[`A`](traverse_.html#A)`) -> Kind<`[`G`](traverse_.html#G)`, `[`B`](traverse_.html#B)`>, FF: Foldable<`[`F`](traverse_.html#F)`>, FG: Foldable<`[`G`](traverse_.html#G)`>): Kind<`[`G`](traverse_.html#G)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>` |

