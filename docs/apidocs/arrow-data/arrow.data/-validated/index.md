---
title: Validated - arrow-data
---

[arrow-data](../../index.html) / [arrow.data](../index.html) / [Validated](./index.html)

# Validated

`@higherkind sealed class Validated<out E, out A> : `[`ValidatedOf`](../-validated-of.html)`<`[`E`](index.html#E)`, `[`A`](index.html#A)`>`

Port of https://github.com/typelevel/cats/blob/master/core/src/main/scala/cats/data/Validated.scala

### Types

| [Invalid](-invalid/index.html) | `data class Invalid<out E> : `[`Validated`](./index.html)`<`[`E`](-invalid/index.html#E)`, `[`Nothing`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing/index.html)`>` |
| [Valid](-valid/index.html) | `data class Valid<out A> : `[`Validated`](./index.html)`<`[`Nothing`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing/index.html)`, `[`A`](-valid/index.html#A)`>` |

### Properties

| [isInvalid](is-invalid.html) | `val isInvalid: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [isValid](is-valid.html) | `val isValid: `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |

### Functions

| [bimap](bimap.html) | `fun <EE, AA> bimap(fe: (`[`E`](index.html#E)`) -> `[`EE`](bimap.html#EE)`, fa: (`[`A`](index.html#A)`) -> `[`AA`](bimap.html#AA)`): `[`Validated`](./index.html)`<`[`EE`](bimap.html#EE)`, `[`AA`](bimap.html#AA)`>`<br>Validated is a [functor.Bifunctor](#), this method applies one of the given functions. |
| [exist](exist.html) | `fun exist(predicate: (`[`A`](index.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Is this Valid and matching the given predicate |
| [fold](fold.html) | `fun <B> fold(fe: (`[`E`](index.html#E)`) -> `[`B`](fold.html#B)`, fa: (`[`A`](index.html#A)`) -> `[`B`](fold.html#B)`): `[`B`](fold.html#B) |
| [foldLeft](fold-left.html) | `fun <B> foldLeft(b: `[`B`](fold-left.html#B)`, f: (`[`B`](fold-left.html#B)`, `[`A`](index.html#A)`) -> `[`B`](fold-left.html#B)`): `[`B`](fold-left.html#B)<br>apply the given function to the value with the given B when valid, otherwise return the given B |
| [foldRight](fold-right.html) | `fun <B> foldRight(lb: Eval<`[`B`](fold-right.html#B)`>, f: (`[`A`](index.html#A)`, Eval<`[`B`](fold-right.html#B)`>) -> Eval<`[`B`](fold-right.html#B)`>): Eval<`[`B`](fold-right.html#B)`>` |
| [leftMap](left-map.html) | `fun <EE> leftMap(f: (`[`E`](index.html#E)`) -> `[`EE`](left-map.html#EE)`): `[`Validated`](./index.html)`<`[`EE`](left-map.html#EE)`, `[`A`](index.html#A)`>`<br>Apply a function to an Invalid value, returning a new Invalid value. Or, if the original valid was Valid, return it. |
| [map](map.html) | `fun <B> map(f: (`[`A`](index.html#A)`) -> `[`B`](map.html#B)`): `[`Validated`](./index.html)`<`[`E`](index.html#E)`, `[`B`](map.html#B)`>`<br>Apply a function to a Valid value, returning a new Valid value |
| [swap](swap.html) | `fun swap(): `[`Validated`](./index.html)`<`[`A`](index.html#A)`, `[`E`](index.html#E)`>` |
| [toEither](to-either.html) | `fun toEither(): Either<`[`E`](index.html#E)`, `[`A`](index.html#A)`>`<br>Converts the value to an Either&lt;E, A&gt; |
| [toList](to-list.html) | `fun toList(): `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`A`](index.html#A)`>`<br>Convert this value to a single element List if it is Valid, otherwise return an empty List |
| [toOption](to-option.html) | `fun toOption(): Option<`[`A`](index.html#A)`>`<br>Returns Valid values wrapped in Some, and None for Invalid values |
| [toValidatedNel](to-validated-nel.html) | `fun toValidatedNel(): `[`ValidatedNel`](../-validated-nel.html)`<`[`E`](index.html#E)`, `[`A`](index.html#A)`>`<br>Lift the Invalid value into a NonEmptyList. |
| [withEither](with-either.html) | `fun <EE, B> withEither(f: (Either<`[`E`](index.html#E)`, `[`A`](index.html#A)`>) -> Either<`[`EE`](with-either.html#EE)`, `[`B`](with-either.html#B)`>): `[`Validated`](./index.html)`<`[`EE`](with-either.html#EE)`, `[`B`](with-either.html#B)`>`<br>Convert to an Either, apply a function, convert back. This is handy when you want to use the Monadic properties of the Either type. |

### Companion Object Functions

| [fromEither](from-either.html) | `fun <E, A> fromEither(e: Either<`[`E`](from-either.html#E)`, `[`A`](from-either.html#A)`>): `[`Validated`](./index.html)`<`[`E`](from-either.html#E)`, `[`A`](from-either.html#A)`>`<br>Converts an `Either<A, B>` to an `Validated<A, B>`. |
| [fromOption](from-option.html) | `fun <E, A> fromOption(o: Option<`[`A`](from-option.html#A)`>, ifNone: () -> `[`E`](from-option.html#E)`): `[`Validated`](./index.html)`<`[`E`](from-option.html#E)`, `[`A`](from-option.html#A)`>`<br>Converts an `Option<B>` to an `Validated<A, B>`, where the provided `ifNone` values is returned on the invalid of the `Validated` when the specified `Option` is `None`. |
| [fromTry](from-try.html) | `fun <A> fromTry(t: Try<`[`A`](from-try.html#A)`>): `[`Validated`](./index.html)`<`[`Throwable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-throwable/index.html)`, `[`A`](from-try.html#A)`>`<br>Converts a `Try<A>` to a `Validated<Throwable, A>`. |
| [invalidNel](invalid-nel.html) | `fun <E, A> invalidNel(e: `[`E`](invalid-nel.html#E)`): `[`ValidatedNel`](../-validated-nel.html)`<`[`E`](invalid-nel.html#E)`, `[`A`](invalid-nel.html#A)`>` |
| [validNel](valid-nel.html) | `fun <E, A> validNel(a: `[`A`](valid-nel.html#A)`): `[`ValidatedNel`](../-validated-nel.html)`<`[`E`](valid-nel.html#E)`, `[`A`](valid-nel.html#A)`>` |

### Extension Functions

| [ap](../arrow.-kind/ap.html) | `fun <E, A, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/ap.html#E)`, `[`A`](../arrow.-kind/ap.html#A)`>.ap(SE: Semigroup<`[`E`](../arrow.-kind/ap.html#E)`>, f: `[`Validated`](./index.html)`<`[`E`](../arrow.-kind/ap.html#E)`, (`[`A`](../arrow.-kind/ap.html#A)`) -> `[`B`](../arrow.-kind/ap.html#B)`>): `[`Validated`](./index.html)`<`[`E`](../arrow.-kind/ap.html#E)`, `[`B`](../arrow.-kind/ap.html#B)`>`<br>From Apply: if both the function and this value are Valid, apply the function |
| [combine](../arrow.-kind/combine.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>.combine(SE: Semigroup<`[`E`](../arrow.-kind/combine.html#E)`>, SA: Semigroup<`[`A`](../arrow.-kind/combine.html#A)`>, y: `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>): `[`Validated`](./index.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>` |
| [combineK](../arrow.-kind/combine-k.html) | `fun <A> `[`ListKOf`](../-list-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`ListKOf`](../-list-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`ListK`](../-list-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`NonEmptyListOf`](../-non-empty-list-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`NonEmptyListOf`](../-non-empty-list-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`NonEmptyList`](../-non-empty-list/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`SequenceK`](../-sequence-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`SetKOf`](../-set-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`SetKOf`](../-set-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`SetK`](../-set-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(SE: Semigroup<`[`E`](../arrow.-kind/combine-k.html#E)`>, y: `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>): `[`Validated`](./index.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>` |
| [findValid](../arrow.-kind/find-valid.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>.findValid(SE: Semigroup<`[`E`](../arrow.-kind/find-valid.html#E)`>, that: () -> `[`Validated`](./index.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>): `[`Validated`](./index.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>`<br>If `this` is valid return `this`, otherwise if `that` is valid return `that`, otherwise combine the failures. This is similar to [orElse](../arrow.-kind/or-else.html) except that here failures are accumulated. |
| [getOrElse](../arrow.-kind/get-or-else.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/get-or-else.html#E)`, `[`B`](../arrow.-kind/get-or-else.html#B)`>.getOrElse(default: () -> `[`B`](../arrow.-kind/get-or-else.html#B)`): `[`B`](../arrow.-kind/get-or-else.html#B)<br>Return the Valid value, or the default if Invalid |
| [handleLeftWith](../arrow.-kind/handle-left-with.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>.handleLeftWith(f: (`[`E`](../arrow.-kind/handle-left-with.html#E)`) -> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>): `[`Validated`](./index.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>` |
| [mapFilter](../arrow.-kind/map-filter.html) | `fun <F, A, B> `[`OptionTOf`](../-option-t-of.html)`<`[`F`](../arrow.-kind/map-filter.html#F)`, `[`A`](../arrow.-kind/map-filter.html#A)`>.mapFilter(FF: Functor<`[`F`](../arrow.-kind/map-filter.html#F)`>, f: (`[`A`](../arrow.-kind/map-filter.html#A)`) -> Option<`[`B`](../arrow.-kind/map-filter.html#B)`>): `[`OptionT`](../-option-t/index.html)`<`[`F`](../arrow.-kind/map-filter.html#F)`, `[`B`](../arrow.-kind/map-filter.html#B)`>` |
| [orElse](../arrow.-kind/or-else.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>.orElse(default: () -> `[`Validated`](./index.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>): `[`Validated`](./index.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>`<br>Return this if it is Valid, or else fall back to the given default. The functionality is similar to that of [findValid](../arrow.-kind/find-valid.html) except for failure accumulation, where here only the error on the right is preserved and the error on the left is ignored. |
| [orNull](../arrow.-kind/or-null.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/or-null.html#E)`, `[`B`](../arrow.-kind/or-null.html#B)`>.orNull(): `[`B`](../arrow.-kind/or-null.html#B)`?`<br>Return the Valid value, or null if Invalid |
| [runM](../arrow.-kind/run-m.html) | `fun <F, S, A> `[`StateTOf`](../-state-t-of.html)`<`[`F`](../arrow.-kind/run-m.html#F)`, `[`S`](../arrow.-kind/run-m.html#S)`, `[`A`](../arrow.-kind/run-m.html#A)`>.runM(MF: Monad<`[`F`](../arrow.-kind/run-m.html#F)`>, initial: `[`S`](../arrow.-kind/run-m.html#S)`): Kind<`[`F`](../arrow.-kind/run-m.html#F)`, Tuple2<`[`S`](../arrow.-kind/run-m.html#S)`, `[`A`](../arrow.-kind/run-m.html#A)`>>`<br>Run the stateful computation within the context `F`. |
| [stateT](../arrow.-kind/state-t.html) | `fun <F, S, A> `[`StateTFunOf`](../-state-t-fun-of.html)`<`[`F`](../arrow.-kind/state-t.html#F)`, `[`S`](../arrow.-kind/state-t.html#S)`, `[`A`](../arrow.-kind/state-t.html#A)`>.stateT(): `[`StateT`](../-state-t/index.html)`<`[`F`](../arrow.-kind/state-t.html#F)`, `[`S`](../arrow.-kind/state-t.html#S)`, `[`A`](../arrow.-kind/state-t.html#A)`>`<br>Wrap the function with [StateT](../-state-t/index.html). |
| [toIor](../arrow.-kind/to-ior.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/to-ior.html#E)`, `[`A`](../arrow.-kind/to-ior.html#A)`>.toIor(): `[`Ior`](../-ior/index.html)`<`[`E`](../arrow.-kind/to-ior.html#E)`, `[`A`](../arrow.-kind/to-ior.html#A)`>`<br>Converts the value to an Ior&lt;E, A&gt; |
| [toList](../arrow.-kind/to-list.html) | `fun <A> `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/to-list.html#A)`>.toList(): `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`A`](../arrow.-kind/to-list.html#A)`>` |
| [traverse](../arrow.-kind/traverse.html) | `fun <G, E, A, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/traverse.html#E)`, `[`A`](../arrow.-kind/traverse.html#A)`>.traverse(GA: Applicative<`[`G`](../arrow.-kind/traverse.html#G)`>, f: (`[`A`](../arrow.-kind/traverse.html#A)`) -> Kind<`[`G`](../arrow.-kind/traverse.html#G)`, `[`B`](../arrow.-kind/traverse.html#B)`>): Kind<`[`G`](../arrow.-kind/traverse.html#G)`, `[`Validated`](./index.html)`<`[`E`](../arrow.-kind/traverse.html#E)`, `[`B`](../arrow.-kind/traverse.html#B)`>>` |
| [valueOr](../arrow.-kind/value-or.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/value-or.html#E)`, `[`B`](../arrow.-kind/value-or.html#B)`>.valueOr(f: (`[`E`](../arrow.-kind/value-or.html#E)`) -> `[`B`](../arrow.-kind/value-or.html#B)`): `[`B`](../arrow.-kind/value-or.html#B)<br>Return the Valid value, or the result of f if Invalid |

### Inheritors

| [Invalid](-invalid/index.html) | `data class Invalid<out E> : `[`Validated`](./index.html)`<`[`E`](-invalid/index.html#E)`, `[`Nothing`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing/index.html)`>` |
| [Valid](-valid/index.html) | `data class Valid<out A> : `[`Validated`](./index.html)`<`[`Nothing`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing/index.html)`, `[`A`](-valid/index.html#A)`>` |

