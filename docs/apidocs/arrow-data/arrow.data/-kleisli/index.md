---
title: Kleisli - arrow-data
---

[arrow-data](../../index.html) / [arrow.data](../index.html) / [Kleisli](./index.html)

# Kleisli

`@higherkind class Kleisli<F, D, A> : `[`KleisliOf`](../-kleisli-of.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`A`](index.html#A)`>, `[`KleisliKindedJ`](../-kleisli-kinded-j.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`A`](index.html#A)`>`

[Kleisli](./index.html) represents an arrow from [D](index.html#D) to a monadic value `Kind<F, A>`.

### Parameters

`F` - the context of the result.

`D` - the dependency or environment we depend on.

`A` - resulting type of the computation.

### Constructors

| [&lt;init&gt;](-init-.html) | `Kleisli(run: `[`KleisliFun`](../-kleisli-fun.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`A`](index.html#A)`>)`<br>[Kleisli](./index.html) represents an arrow from [D](index.html#D) to a monadic value `Kind<F, A>`. |

### Properties

| [run](run.html) | `val run: `[`KleisliFun`](../-kleisli-fun.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`A`](index.html#A)`>`<br>the arrow from [D](index.html#D) to `Kind<F, A>`. |

### Functions

| [andThen](and-then.html) | `fun <C> andThen(MF: Monad<`[`F`](index.html#F)`>, f: `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`A`](index.html#A)`, `[`C`](and-then.html#C)`>): `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`C`](and-then.html#C)`>`<br>Compose with another [Kleisli](./index.html).`fun <B> andThen(MF: Monad<`[`F`](index.html#F)`>, f: (`[`A`](index.html#A)`) -> Kind<`[`F`](index.html#F)`, `[`B`](and-then.html#B)`>): `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`B`](and-then.html#B)`>`<br>Compose with a function to transform the output of the [Kleisli](./index.html) arrow.`fun <B> andThen(MF: Monad<`[`F`](index.html#F)`>, fb: Kind<`[`F`](index.html#F)`, `[`B`](and-then.html#B)`>): `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`B`](and-then.html#B)`>`<br>Set the end of the arrow to `Kind<F, B>` after running the computation. |
| [ap](ap.html) | `fun <B> ap(AF: Applicative<`[`F`](index.html#F)`>, ff: `[`KleisliOf`](../-kleisli-of.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, (`[`A`](index.html#A)`) -> `[`B`](ap.html#B)`>): `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`B`](ap.html#B)`>`<br>Apply a function `(A) -> B` that operates within the [Kleisli](./index.html) context. |
| [flatMap](flat-map.html) | `fun <B> flatMap(MF: Monad<`[`F`](index.html#F)`>, f: (`[`A`](index.html#A)`) -> `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`B`](flat-map.html#B)`>): `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`B`](flat-map.html#B)`>`<br>FlatMap the end of the arrow [A](index.html#A) to another [Kleisli](./index.html) arrow for the same start [D](index.html#D) and context [F](index.html#F). |
| [handleErrorWith](handle-error-with.html) | `fun <E> handleErrorWith(AE: ApplicativeError<`[`F`](index.html#F)`, `[`E`](handle-error-with.html#E)`>, f: (`[`E`](handle-error-with.html#E)`) -> `[`KleisliOf`](../-kleisli-of.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`A`](index.html#A)`>): `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`A`](index.html#A)`>`<br>Handle error within context of [F](index.html#F) given a [ApplicativeError](#) is defined for [F](index.html#F). |
| [local](local.html) | `fun <DD> local(f: (`[`DD`](local.html#DD)`) -> `[`D`](index.html#D)`): `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`DD`](local.html#DD)`, `[`A`](index.html#A)`>`<br>Compose this arrow with another function to transform the input of the arrow. |
| [map](map.html) | `fun <B> map(FF: Functor<`[`F`](index.html#F)`>, f: (`[`A`](index.html#A)`) -> `[`B`](map.html#B)`): `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`B`](map.html#B)`>`<br>Map the end of the arrow [A](index.html#A) to [B](map.html#B) given a function [f](map.html#arrow.data.Kleisli$map(arrow.typeclasses.Functor((arrow.data.Kleisli.F)), kotlin.Function1((arrow.data.Kleisli.A, arrow.data.Kleisli.map.B)))/f). |
| [zip](zip.html) | `fun <B> zip(MF: Monad<`[`F`](index.html#F)`>, o: `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, `[`B`](zip.html#B)`>): `[`Kleisli`](./index.html)`<`[`F`](index.html#F)`, `[`D`](index.html#D)`, Tuple2<`[`A`](index.html#A)`, `[`B`](zip.html#B)`>>`<br>Zip with another [Kleisli](./index.html) arrow. |

### Companion Object Functions

| [ask](ask.html) | `fun <F, D> ask(AF: Applicative<`[`F`](ask.html#F)`>): `[`Kleisli`](./index.html)`<`[`F`](ask.html#F)`, `[`D`](ask.html#D)`, `[`D`](ask.html#D)`>`<br>Ask an arrow from [D](ask.html#D) to [D](ask.html#D). |
| [invoke](invoke.html) | `operator fun <F, D, A> invoke(run: `[`KleisliFun`](../-kleisli-fun.html)`<`[`F`](invoke.html#F)`, `[`D`](invoke.html#D)`, `[`A`](invoke.html#A)`>): `[`Kleisli`](./index.html)`<`[`F`](invoke.html#F)`, `[`D`](invoke.html#D)`, `[`A`](invoke.html#A)`>`<br>Constructor to create `Kleisli<F, D, A>` given a [KleisliFun](../-kleisli-fun.html). |
| [just](just.html) | `fun <F, D, A> just(AF: Applicative<`[`F`](just.html#F)`>, x: `[`A`](just.html#A)`): `[`Kleisli`](./index.html)`<`[`F`](just.html#F)`, `[`D`](just.html#D)`, `[`A`](just.html#A)`>`<br>Create an arrow for a value of [A](just.html#A). |
| [raiseError](raise-error.html) | `fun <F, D, E, A> raiseError(AE: ApplicativeError<`[`F`](raise-error.html#F)`, `[`E`](raise-error.html#E)`>, e: `[`E`](raise-error.html#E)`): `[`Kleisli`](./index.html)`<`[`F`](raise-error.html#F)`, `[`D`](raise-error.html#D)`, `[`A`](raise-error.html#A)`>`<br>Raise an error [E](raise-error.html#E). |
| [tailRecM](tail-rec-m.html) | `fun <F, D, A, B> tailRecM(MF: Monad<`[`F`](tail-rec-m.html#F)`>, a: `[`A`](tail-rec-m.html#A)`, f: (`[`A`](tail-rec-m.html#A)`) -> `[`KleisliOf`](../-kleisli-of.html)`<`[`F`](tail-rec-m.html#F)`, `[`D`](tail-rec-m.html#D)`, Either<`[`A`](tail-rec-m.html#A)`, `[`B`](tail-rec-m.html#B)`>>): `[`Kleisli`](./index.html)`<`[`F`](tail-rec-m.html#F)`, `[`D`](tail-rec-m.html#D)`, `[`B`](tail-rec-m.html#B)`>`<br>Tail recursive function that keeps calling [f](tail-rec-m.html#arrow.data.Kleisli.Companion$tailRecM(arrow.typeclasses.Monad((arrow.data.Kleisli.Companion.tailRecM.F)), arrow.data.Kleisli.Companion.tailRecM.A, kotlin.Function1((arrow.data.Kleisli.Companion.tailRecM.A, arrow.Kind((arrow.Kind((arrow.Kind((arrow.data.ForKleisli, arrow.data.Kleisli.Companion.tailRecM.F)), arrow.data.Kleisli.Companion.tailRecM.D)), arrow.core.Either((, arrow.data.Kleisli.Companion.tailRecM.B)))))))/f) until [arrow.Either.Right](#) is returned. |

### Extension Functions

| [andThen](../and-then.html) | `fun <D, A, C> `[`Reader`](../-reader.html)`<`[`D`](../and-then.html#D)`, `[`A`](../and-then.html#A)`>.andThen(o: `[`Reader`](../-reader.html)`<`[`A`](../and-then.html#A)`, `[`C`](../and-then.html#C)`>): `[`Reader`](../-reader.html)`<`[`D`](../and-then.html#D)`, `[`C`](../and-then.html#C)`>`<br>Compose with another [Reader](../-reader.html) that has a dependency on the output of the computation.`fun <D, A, B> `[`Reader`](../-reader.html)`<`[`D`](../and-then.html#D)`, `[`A`](../and-then.html#A)`>.andThen(f: (`[`A`](../and-then.html#A)`) -> `[`B`](../and-then.html#B)`): `[`Reader`](../-reader.html)`<`[`D`](../and-then.html#D)`, `[`B`](../and-then.html#B)`>`<br>Map the result of the computation [A](../and-then.html#A) to [B](../and-then.html#B) given a function [f](../and-then.html#arrow.data$andThen(arrow.data.Kleisli((arrow.core.ForId, arrow.data.andThen.D, arrow.data.andThen.A)), kotlin.Function1((arrow.data.andThen.A, arrow.data.andThen.B)))/f). Alias for [map](../map.html)`fun <D, A, B> `[`Reader`](../-reader.html)`<`[`D`](../and-then.html#D)`, `[`A`](../and-then.html#A)`>.andThen(b: `[`B`](../and-then.html#B)`): `[`Reader`](../-reader.html)`<`[`D`](../and-then.html#D)`, `[`B`](../and-then.html#B)`>`<br>Set the result to [B](../and-then.html#B) after running the computation. |
| [ap](../ap.html) | `fun <D, A, B> `[`Reader`](../-reader.html)`<`[`D`](../ap.html#D)`, `[`A`](../ap.html#A)`>.ap(ff: `[`ReaderOf`](../-reader-of.html)`<`[`D`](../ap.html#D)`, (`[`A`](../ap.html#A)`) -> `[`B`](../ap.html#B)`>): `[`Reader`](../-reader.html)`<`[`D`](../ap.html#D)`, `[`B`](../ap.html#B)`>`<br>Apply a function `(A) -> B` that operates within the context of [Reader](../-reader.html). |
| [ap](../arrow.-kind/ap.html) | `fun <E, A, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/ap.html#E)`, `[`A`](../arrow.-kind/ap.html#A)`>.ap(SE: Semigroup<`[`E`](../arrow.-kind/ap.html#E)`>, f: `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/ap.html#E)`, (`[`A`](../arrow.-kind/ap.html#A)`) -> `[`B`](../arrow.-kind/ap.html#B)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/ap.html#E)`, `[`B`](../arrow.-kind/ap.html#B)`>`<br>From Apply: if both the function and this value are Valid, apply the function |
| [combine](../arrow.-kind/combine.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>.combine(SE: Semigroup<`[`E`](../arrow.-kind/combine.html#E)`>, SA: Semigroup<`[`A`](../arrow.-kind/combine.html#A)`>, y: `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>` |
| [combineK](../arrow.-kind/combine-k.html) | `fun <A> `[`ListKOf`](../-list-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`ListKOf`](../-list-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`ListK`](../-list-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`NonEmptyListOf`](../-non-empty-list-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`NonEmptyListOf`](../-non-empty-list-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`NonEmptyList`](../-non-empty-list/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`SequenceK`](../-sequence-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`SetKOf`](../-set-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`SetKOf`](../-set-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`SetK`](../-set-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(SE: Semigroup<`[`E`](../arrow.-kind/combine-k.html#E)`>, y: `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>` |
| [findValid](../arrow.-kind/find-valid.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>.findValid(SE: Semigroup<`[`E`](../arrow.-kind/find-valid.html#E)`>, that: () -> `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>`<br>If `this` is valid return `this`, otherwise if `that` is valid return `that`, otherwise combine the failures. This is similar to [orElse](../arrow.-kind/or-else.html) except that here failures are accumulated. |
| [flatMap](../flat-map.html) | `fun <D, A, B> `[`Reader`](../-reader.html)`<`[`D`](../flat-map.html#D)`, `[`A`](../flat-map.html#A)`>.flatMap(f: (`[`A`](../flat-map.html#A)`) -> `[`Reader`](../-reader.html)`<`[`D`](../flat-map.html#D)`, `[`B`](../flat-map.html#B)`>): `[`Reader`](../-reader.html)`<`[`D`](../flat-map.html#D)`, `[`B`](../flat-map.html#B)`>`<br>FlatMap the result of the computation [A](../flat-map.html#A) to another [Reader](../-reader.html) for the same dependency [D](../flat-map.html#D) and flatten the structure. |
| [getOrElse](../arrow.-kind/get-or-else.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/get-or-else.html#E)`, `[`B`](../arrow.-kind/get-or-else.html#B)`>.getOrElse(default: () -> `[`B`](../arrow.-kind/get-or-else.html#B)`): `[`B`](../arrow.-kind/get-or-else.html#B)<br>Return the Valid value, or the default if Invalid |
| [handleLeftWith](../arrow.-kind/handle-left-with.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>.handleLeftWith(f: (`[`E`](../arrow.-kind/handle-left-with.html#E)`) -> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>` |
| [map](../map.html) | `fun <D, A, B> `[`Reader`](../-reader.html)`<`[`D`](../map.html#D)`, `[`A`](../map.html#A)`>.map(f: (`[`A`](../map.html#A)`) -> `[`B`](../map.html#B)`): `[`Reader`](../-reader.html)`<`[`D`](../map.html#D)`, `[`B`](../map.html#B)`>`<br>Map the result of the computation [A](../map.html#A) to [B](../map.html#B) given a function [f](../map.html#arrow.data$map(arrow.data.Kleisli((arrow.core.ForId, arrow.data.map.D, arrow.data.map.A)), kotlin.Function1((arrow.data.map.A, arrow.data.map.B)))/f). |
| [mapFilter](../arrow.-kind/map-filter.html) | `fun <F, A, B> `[`OptionTOf`](../-option-t-of.html)`<`[`F`](../arrow.-kind/map-filter.html#F)`, `[`A`](../arrow.-kind/map-filter.html#A)`>.mapFilter(FF: Functor<`[`F`](../arrow.-kind/map-filter.html#F)`>, f: (`[`A`](../arrow.-kind/map-filter.html#A)`) -> Option<`[`B`](../arrow.-kind/map-filter.html#B)`>): `[`OptionT`](../-option-t/index.html)`<`[`F`](../arrow.-kind/map-filter.html#F)`, `[`B`](../arrow.-kind/map-filter.html#B)`>` |
| [orElse](../arrow.-kind/or-else.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>.orElse(default: () -> `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>`<br>Return this if it is Valid, or else fall back to the given default. The functionality is similar to that of [findValid](../arrow.-kind/find-valid.html) except for failure accumulation, where here only the error on the right is preserved and the error on the left is ignored. |
| [orNull](../arrow.-kind/or-null.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/or-null.html#E)`, `[`B`](../arrow.-kind/or-null.html#B)`>.orNull(): `[`B`](../arrow.-kind/or-null.html#B)`?`<br>Return the Valid value, or null if Invalid |
| [runId](../run-id.html) | `fun <D, A> `[`Reader`](../-reader.html)`<`[`D`](../run-id.html#D)`, `[`A`](../run-id.html#A)`>.runId(d: `[`D`](../run-id.html#D)`): `[`A`](../run-id.html#A)<br>Alias for [Kleisli.run](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html) |
| [runM](../arrow.-kind/run-m.html) | `fun <F, S, A> `[`StateTOf`](../-state-t-of.html)`<`[`F`](../arrow.-kind/run-m.html#F)`, `[`S`](../arrow.-kind/run-m.html#S)`, `[`A`](../arrow.-kind/run-m.html#A)`>.runM(MF: Monad<`[`F`](../arrow.-kind/run-m.html#F)`>, initial: `[`S`](../arrow.-kind/run-m.html#S)`): Kind<`[`F`](../arrow.-kind/run-m.html#F)`, Tuple2<`[`S`](../arrow.-kind/run-m.html#S)`, `[`A`](../arrow.-kind/run-m.html#A)`>>`<br>Run the stateful computation within the context `F`. |
| [stateT](../arrow.-kind/state-t.html) | `fun <F, S, A> `[`StateTFunOf`](../-state-t-fun-of.html)`<`[`F`](../arrow.-kind/state-t.html#F)`, `[`S`](../arrow.-kind/state-t.html#S)`, `[`A`](../arrow.-kind/state-t.html#A)`>.stateT(): `[`StateT`](../-state-t/index.html)`<`[`F`](../arrow.-kind/state-t.html#F)`, `[`S`](../arrow.-kind/state-t.html#S)`, `[`A`](../arrow.-kind/state-t.html#A)`>`<br>Wrap the function with [StateT](../-state-t/index.html). |
| [toIor](../arrow.-kind/to-ior.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/to-ior.html#E)`, `[`A`](../arrow.-kind/to-ior.html#A)`>.toIor(): `[`Ior`](../-ior/index.html)`<`[`E`](../arrow.-kind/to-ior.html#E)`, `[`A`](../arrow.-kind/to-ior.html#A)`>`<br>Converts the value to an Ior&lt;E, A&gt; |
| [toList](../arrow.-kind/to-list.html) | `fun <A> `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/to-list.html#A)`>.toList(): `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`A`](../arrow.-kind/to-list.html#A)`>` |
| [traverse](../arrow.-kind/traverse.html) | `fun <G, E, A, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/traverse.html#E)`, `[`A`](../arrow.-kind/traverse.html#A)`>.traverse(GA: Applicative<`[`G`](../arrow.-kind/traverse.html#G)`>, f: (`[`A`](../arrow.-kind/traverse.html#A)`) -> Kind<`[`G`](../arrow.-kind/traverse.html#G)`, `[`B`](../arrow.-kind/traverse.html#B)`>): Kind<`[`G`](../arrow.-kind/traverse.html#G)`, `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/traverse.html#E)`, `[`B`](../arrow.-kind/traverse.html#B)`>>` |
| [valueOr](../arrow.-kind/value-or.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/value-or.html#E)`, `[`B`](../arrow.-kind/value-or.html#B)`>.valueOr(f: (`[`E`](../arrow.-kind/value-or.html#E)`) -> `[`B`](../arrow.-kind/value-or.html#B)`): `[`B`](../arrow.-kind/value-or.html#B)<br>Return the Valid value, or the result of f if Invalid |
| [zip](../zip.html) | `fun <D, A, B> `[`Reader`](../-reader.html)`<`[`D`](../zip.html#D)`, `[`A`](../zip.html#A)`>.zip(o: `[`Reader`](../-reader.html)`<`[`D`](../zip.html#D)`, `[`B`](../zip.html#B)`>): `[`Reader`](../-reader.html)`<`[`D`](../zip.html#D)`, Tuple2<`[`A`](../zip.html#A)`, `[`B`](../zip.html#B)`>>`<br>Zip with another [Reader](../-reader.html). |

