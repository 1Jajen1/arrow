---
title: Traverse - arrow-typeclasses
---

[arrow-typeclasses](../../index.html) / [arrow.typeclasses](../index.html) / [Traverse](./index.html)

# Traverse

`interface Traverse<F> : `[`Functor`](../-functor/index.html)`<`[`F`](index.html#F)`>, `[`Foldable`](../-foldable/index.html)`<`[`F`](index.html#F)`>`



Traverse, also known as Traversable. Traversal over a structure with an effect.

### Functions

| [flatTraverse](flat-traverse.html) | `open fun <G, A, B> Kind<`[`F`](index.html#F)`, `[`A`](flat-traverse.html#A)`>.flatTraverse(MF: `[`Monad`](../-monad/index.html)`<`[`F`](index.html#F)`>, AG: `[`Applicative`](../-applicative/index.html)`<`[`G`](flat-traverse.html#G)`>, f: (`[`A`](flat-traverse.html#A)`) -> Kind<`[`G`](flat-traverse.html#G)`, Kind<`[`F`](index.html#F)`, `[`B`](flat-traverse.html#B)`>>): Kind<`[`G`](flat-traverse.html#G)`, Kind<`[`F`](index.html#F)`, `[`B`](flat-traverse.html#B)`>>` |
| [map](map.html) | `open fun <A, B> Kind<`[`F`](index.html#F)`, `[`A`](map.html#A)`>.map(f: (`[`A`](map.html#A)`) -> `[`B`](map.html#B)`): Kind<`[`F`](index.html#F)`, `[`B`](map.html#B)`>` |
| [sequence](sequence.html) | `open fun <G, A> Kind<`[`F`](index.html#F)`, Kind<`[`G`](sequence.html#G)`, `[`A`](sequence.html#A)`>>.sequence(AG: `[`Applicative`](../-applicative/index.html)`<`[`G`](sequence.html#G)`>): Kind<`[`G`](sequence.html#G)`, Kind<`[`F`](index.html#F)`, `[`A`](sequence.html#A)`>>`<br>Thread all the G effects through the F structure to invert the structure from F&lt;G&gt; to G&lt;F&gt;. |
| [traverse](traverse.html) | `abstract fun <G, A, B> Kind<`[`F`](index.html#F)`, `[`A`](traverse.html#A)`>.traverse(AP: `[`Applicative`](../-applicative/index.html)`<`[`G`](traverse.html#G)`>, f: (`[`A`](traverse.html#A)`) -> Kind<`[`G`](traverse.html#G)`, `[`B`](traverse.html#B)`>): Kind<`[`G`](traverse.html#G)`, Kind<`[`F`](index.html#F)`, `[`B`](traverse.html#B)`>>`<br>Given a function which returns a G effect, thread this effect through the running of this function on all the values in F, returning an F in a G context. |

### Inherited Functions

| [as](../-functor/as.html) | `open fun <A, B> Kind<`[`F`](../-functor/index.html#F)`, `[`A`](../-functor/as.html#A)`>.as(b: `[`B`](../-functor/as.html#B)`): Kind<`[`F`](../-functor/index.html#F)`, `[`B`](../-functor/as.html#B)`>` |
| [combineAll](../-foldable/combine-all.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/combine-all.html#A)`>.combineAll(MN: `[`Monoid`](../-monoid/index.html)`<`[`A`](../-foldable/combine-all.html#A)`>): `[`A`](../-foldable/combine-all.html#A)<br>Alias for fold. |
| [exists](../-foldable/exists.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/exists.html#A)`>.exists(p: (`[`A`](../-foldable/exists.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check whether at least one element satisfies the predicate. |
| [find](../-foldable/find.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/find.html#A)`>.find(f: (`[`A`](../-foldable/find.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): Option<`[`A`](../-foldable/find.html#A)`>`<br>Find the first element matching the predicate, if one exists. |
| [fold](../-foldable/fold.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/fold.html#A)`>.fold(MN: `[`Monoid`](../-monoid/index.html)`<`[`A`](../-foldable/fold.html#A)`>): `[`A`](../-foldable/fold.html#A)<br>Fold implemented using the given Monoid instance. |
| [foldLeft](../-foldable/fold-left.html) | `abstract fun <A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/fold-left.html#A)`>.foldLeft(b: `[`B`](../-foldable/fold-left.html#B)`, f: (`[`B`](../-foldable/fold-left.html#B)`, `[`A`](../-foldable/fold-left.html#A)`) -> `[`B`](../-foldable/fold-left.html#B)`): `[`B`](../-foldable/fold-left.html#B)<br>Left associative fold on F using the provided function. |
| [foldM](../-foldable/fold-m.html) | `open fun <G, A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/fold-m.html#A)`>.foldM(M: `[`Monad`](../-monad/index.html)`<`[`G`](../-foldable/fold-m.html#G)`>, z: `[`B`](../-foldable/fold-m.html#B)`, f: (`[`B`](../-foldable/fold-m.html#B)`, `[`A`](../-foldable/fold-m.html#A)`) -> Kind<`[`G`](../-foldable/fold-m.html#G)`, `[`B`](../-foldable/fold-m.html#B)`>): Kind<`[`G`](../-foldable/fold-m.html#G)`, `[`B`](../-foldable/fold-m.html#B)`>`<br>Left associative monadic folding on F. |
| [foldMap](../-foldable/fold-map.html) | `open fun <A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/fold-map.html#A)`>.foldMap(MN: `[`Monoid`](../-monoid/index.html)`<`[`B`](../-foldable/fold-map.html#B)`>, f: (`[`A`](../-foldable/fold-map.html#A)`) -> `[`B`](../-foldable/fold-map.html#B)`): `[`B`](../-foldable/fold-map.html#B)<br>Fold implemented by mapping A values into B and then combining them using the given Monoid instance. |
| [foldMapM](../-foldable/fold-map-m.html) | `open fun <G, A, B, MA : `[`Monad`](../-monad/index.html)`<`[`G`](../-foldable/fold-map-m.html#G)`>, MO : `[`Monoid`](../-monoid/index.html)`<`[`B`](../-foldable/fold-map-m.html#B)`>> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/fold-map-m.html#A)`>.foldMapM(ma: `[`MA`](../-foldable/fold-map-m.html#MA)`, mo: `[`MO`](../-foldable/fold-map-m.html#MO)`, f: (`[`A`](../-foldable/fold-map-m.html#A)`) -> Kind<`[`G`](../-foldable/fold-map-m.html#G)`, `[`B`](../-foldable/fold-map-m.html#B)`>): Kind<`[`G`](../-foldable/fold-map-m.html#G)`, `[`B`](../-foldable/fold-map-m.html#B)`>`<br>Monadic folding on F by mapping A values to G, combining the B values using the given Monoid instance. |
| [foldRight](../-foldable/fold-right.html) | `abstract fun <A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/fold-right.html#A)`>.foldRight(lb: Eval<`[`B`](../-foldable/fold-right.html#B)`>, f: (`[`A`](../-foldable/fold-right.html#A)`, Eval<`[`B`](../-foldable/fold-right.html#B)`>) -> Eval<`[`B`](../-foldable/fold-right.html#B)`>): Eval<`[`B`](../-foldable/fold-right.html#B)`>`<br>Right associative lazy fold on F using the provided function. |
| [forAll](../-foldable/for-all.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/for-all.html#A)`>.forAll(p: (`[`A`](../-foldable/for-all.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check whether all elements satisfy the predicate. |
| [fproduct](../-functor/fproduct.html) | `open fun <A, B> Kind<`[`F`](../-functor/index.html#F)`, `[`A`](../-functor/fproduct.html#A)`>.fproduct(f: (`[`A`](../-functor/fproduct.html#A)`) -> `[`B`](../-functor/fproduct.html#B)`): Kind<`[`F`](../-functor/index.html#F)`, Tuple2<`[`A`](../-functor/fproduct.html#A)`, `[`B`](../-functor/fproduct.html#B)`>>` |
| [get](../-foldable/get.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/get.html#A)`>.get(M: `[`Monad`](../-monad/index.html)`<Kind<ForEither, `[`A`](../-foldable/get.html#A)`>>, idx: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): Option<`[`A`](../-foldable/get.html#A)`>`<br>Get the element at the index of the Foldable. |
| [imap](../-functor/imap.html) | `open fun <A, B> Kind<`[`F`](../-functor/index.html#F)`, `[`A`](../-functor/imap.html#A)`>.imap(f: (`[`A`](../-functor/imap.html#A)`) -> `[`B`](../-functor/imap.html#B)`, g: (`[`B`](../-functor/imap.html#B)`) -> `[`A`](../-functor/imap.html#A)`): Kind<`[`F`](../-functor/index.html#F)`, `[`B`](../-functor/imap.html#B)`>` |
| [isEmpty](../-foldable/is-empty.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/is-empty.html#A)`>.isEmpty(): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if there are no elements. Otherwise false. |
| [lift](../-functor/lift.html) | `open fun <A, B> lift(f: (`[`A`](../-functor/lift.html#A)`) -> `[`B`](../-functor/lift.html#B)`): (Kind<`[`F`](../-functor/index.html#F)`, `[`A`](../-functor/lift.html#A)`>) -> Kind<`[`F`](../-functor/index.html#F)`, `[`B`](../-functor/lift.html#B)`>` |
| [nonEmpty](../-foldable/non-empty.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/non-empty.html#A)`>.nonEmpty(): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [reduceLeftOption](../-foldable/reduce-left-option.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/reduce-left-option.html#A)`>.reduceLeftOption(f: (`[`A`](../-foldable/reduce-left-option.html#A)`, `[`A`](../-foldable/reduce-left-option.html#A)`) -> `[`A`](../-foldable/reduce-left-option.html#A)`): Option<`[`A`](../-foldable/reduce-left-option.html#A)`>`<br>Reduce the elements of this structure down to a single value by applying the provided aggregation function in a left-associative manner. |
| [reduceLeftToOption](../-foldable/reduce-left-to-option.html) | `open fun <A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/reduce-left-to-option.html#A)`>.reduceLeftToOption(f: (`[`A`](../-foldable/reduce-left-to-option.html#A)`) -> `[`B`](../-foldable/reduce-left-to-option.html#B)`, g: (`[`B`](../-foldable/reduce-left-to-option.html#B)`, `[`A`](../-foldable/reduce-left-to-option.html#A)`) -> `[`B`](../-foldable/reduce-left-to-option.html#B)`): Option<`[`B`](../-foldable/reduce-left-to-option.html#B)`>` |
| [reduceRightOption](../-foldable/reduce-right-option.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/reduce-right-option.html#A)`>.reduceRightOption(f: (`[`A`](../-foldable/reduce-right-option.html#A)`, Eval<`[`A`](../-foldable/reduce-right-option.html#A)`>) -> Eval<`[`A`](../-foldable/reduce-right-option.html#A)`>): Eval<Option<`[`A`](../-foldable/reduce-right-option.html#A)`>>`<br>Reduce the elements of this structure down to a single value by applying the provided aggregation function in a right-associative manner. |
| [reduceRightToOption](../-foldable/reduce-right-to-option.html) | `open fun <A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/reduce-right-to-option.html#A)`>.reduceRightToOption(f: (`[`A`](../-foldable/reduce-right-to-option.html#A)`) -> `[`B`](../-foldable/reduce-right-to-option.html#B)`, g: (`[`A`](../-foldable/reduce-right-to-option.html#A)`, Eval<`[`B`](../-foldable/reduce-right-to-option.html#B)`>) -> Eval<`[`B`](../-foldable/reduce-right-to-option.html#B)`>): Eval<Option<`[`B`](../-foldable/reduce-right-to-option.html#B)`>>` |
| [sequence_](../-foldable/sequence_.html) | `open fun <G, A> Kind<`[`F`](../-foldable/index.html#F)`, Kind<`[`G`](../-foldable/sequence_.html#G)`, `[`A`](../-foldable/sequence_.html#A)`>>.sequence_(ag: `[`Applicative`](../-applicative/index.html)`<`[`G`](../-foldable/sequence_.html#G)`>): Kind<`[`G`](../-foldable/sequence_.html#G)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Sequence F&lt;G&gt; using Applicative. |
| [size](../-foldable/size.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/size.html#A)`>.size(MN: `[`Monoid`](../-monoid/index.html)`<`[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`>): `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The size of this Foldable. |
| [traverse_](../-foldable/traverse_.html) | `open fun <G, A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/traverse_.html#A)`>.traverse_(GA: `[`Applicative`](../-applicative/index.html)`<`[`G`](../-foldable/traverse_.html#G)`>, f: (`[`A`](../-foldable/traverse_.html#A)`) -> Kind<`[`G`](../-foldable/traverse_.html#G)`, `[`B`](../-foldable/traverse_.html#B)`>): Kind<`[`G`](../-foldable/traverse_.html#G)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Traverse F using Applicative. |
| [tupleLeft](../-functor/tuple-left.html) | `open fun <A, B> Kind<`[`F`](../-functor/index.html#F)`, `[`A`](../-functor/tuple-left.html#A)`>.tupleLeft(b: `[`B`](../-functor/tuple-left.html#B)`): Kind<`[`F`](../-functor/index.html#F)`, Tuple2<`[`B`](../-functor/tuple-left.html#B)`, `[`A`](../-functor/tuple-left.html#A)`>>` |
| [tupleRight](../-functor/tuple-right.html) | `open fun <A, B> Kind<`[`F`](../-functor/index.html#F)`, `[`A`](../-functor/tuple-right.html#A)`>.tupleRight(b: `[`B`](../-functor/tuple-right.html#B)`): Kind<`[`F`](../-functor/index.html#F)`, Tuple2<`[`A`](../-functor/tuple-right.html#A)`, `[`B`](../-functor/tuple-right.html#B)`>>` |
| [void](../-functor/void.html) | `open fun <A> Kind<`[`F`](../-functor/index.html#F)`, `[`A`](../-functor/void.html#A)`>.void(): Kind<`[`F`](../-functor/index.html#F)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>` |
| [widen](../-functor/widen.html) | `open fun <B, A : `[`B`](../-functor/widen.html#B)`> Kind<`[`F`](../-functor/index.html#F)`, `[`A`](../-functor/widen.html#A)`>.widen(): Kind<`[`F`](../-functor/index.html#F)`, `[`B`](../-functor/widen.html#B)`>` |

### Extension Functions

| [compose](../compose.html) | `fun <F, G> `[`Traverse`](./index.html)`<`[`F`](../compose.html#F)`>.compose(GT: `[`Traverse`](./index.html)`<`[`G`](../compose.html#G)`>, GA: `[`Applicative`](../-applicative/index.html)`<`[`G`](../compose.html#G)`>): `[`Traverse`](./index.html)`<`[`Nested`](../-nested.html)`<`[`F`](../compose.html#F)`, `[`G`](../compose.html#G)`>>`<br>`fun <F, G> `[`Foldable`](../-foldable/index.html)`<`[`F`](../compose.html#F)`>.compose(GT: `[`Foldable`](../-foldable/index.html)`<`[`G`](../compose.html#G)`>): `[`ComposedFoldable`](../-composed-foldable/index.html)`<`[`F`](../compose.html#F)`, `[`G`](../compose.html#G)`>`<br>`fun <F, G> `[`Invariant`](../-invariant/index.html)`<`[`F`](../compose.html#F)`>.compose(GF: `[`Invariant`](../-invariant/index.html)`<`[`G`](../compose.html#G)`>): `[`Invariant`](../-invariant/index.html)`<`[`Nested`](../-nested.html)`<`[`F`](../compose.html#F)`, `[`G`](../compose.html#G)`>>`<br>`fun <F, G> `[`Functor`](../-functor/index.html)`<`[`F`](../compose.html#F)`>.compose(GF: `[`Functor`](../-functor/index.html)`<`[`G`](../compose.html#G)`>): `[`Functor`](../-functor/index.html)`<`[`Nested`](../-nested.html)`<`[`F`](../compose.html#F)`, `[`G`](../compose.html#G)`>>` |
| [composeContravariant](../compose-contravariant.html) | `fun <F, G> `[`Invariant`](../-invariant/index.html)`<`[`F`](../compose-contravariant.html#F)`>.composeContravariant(GF: `[`Contravariant`](../-contravariant/index.html)`<`[`G`](../compose-contravariant.html#G)`>): `[`Invariant`](../-invariant/index.html)`<`[`Nested`](../-nested.html)`<`[`F`](../compose-contravariant.html#F)`, `[`G`](../compose-contravariant.html#G)`>>`<br>`fun <F, G> `[`Functor`](../-functor/index.html)`<`[`F`](../compose-contravariant.html#F)`>.composeContravariant(GF: `[`Contravariant`](../-contravariant/index.html)`<`[`G`](../compose-contravariant.html#G)`>): `[`Contravariant`](../-contravariant/index.html)`<`[`Nested`](../-nested.html)`<`[`F`](../compose-contravariant.html#F)`, `[`G`](../compose-contravariant.html#G)`>>` |
| [composeFunctor](../compose-functor.html) | `fun <F, G> `[`Invariant`](../-invariant/index.html)`<`[`F`](../compose-functor.html#F)`>.composeFunctor(GF: `[`Functor`](../-functor/index.html)`<`[`G`](../compose-functor.html#G)`>): `[`Invariant`](../-invariant/index.html)`<`[`Nested`](../-nested.html)`<`[`F`](../compose-functor.html#F)`, `[`G`](../compose-functor.html#G)`>>` |

### Inheritors

| [ComposedTraverse](../-composed-traverse/index.html) | `interface ComposedTraverse<F, G> : `[`Traverse`](./index.html)`<`[`Nested`](../-nested.html)`<`[`F`](../-composed-traverse/index.html#F)`, `[`G`](../-composed-traverse/index.html#G)`>>, `[`ComposedFoldable`](../-composed-foldable/index.html)`<`[`F`](../-composed-traverse/index.html#F)`, `[`G`](../-composed-traverse/index.html#G)`>` |




## Type Class Hierarchy

<canvas id="arrow.typeclasses-hierarchy-diagram"></canvas>
<script>
  drawNomNomlDiagram('arrow.typeclasses-hierarchy-diagram', 'arrow.typeclasses-diagram.nomnol')
</script>

