$dokka.format:jekyll
$dokka.linkExtension:html
$dokka.location:arrow.mtl.instances$extensions(arrow.core.ForOption.Companion, kotlin.Function1((arrow.mtl.instances.OptionMtlContext, arrow.mtl.instances.extensions.A)))arrow.mtl.instances/arrow.core.-for-option/extensions.html
$dokka.location:arrow.mtl.instances$extensions(arrow.data.ForListK.Companion, kotlin.Function1((arrow.mtl.instances.ListKMtlContext, arrow.mtl.instances.extensions.A)))arrow.mtl.instances/arrow.data.-for-list-k/extensions.html
$dokka.location:arrow.mtl.instances$extensions(arrow.data.ForSequenceK.Companion, kotlin.Function1((arrow.mtl.instances.SequenceKMtlContext, arrow.mtl.instances.extensions.A)))arrow.mtl.instances/arrow.data.-for-sequence-k/extensions.html
$dokka.location:arrow.mtl.instances$traverseFilter(arrow.data.OptionT((arrow.mtl.instances.traverseFilter.F, arrow.mtl.instances.traverseFilter.A)), kotlin.Function1((arrow.mtl.instances.traverseFilter.A, arrow.Kind((arrow.mtl.instances.traverseFilter.G, arrow.core.Option((arrow.mtl.instances.traverseFilter.B)))))), arrow.typeclasses.Applicative((arrow.mtl.instances.traverseFilter.G)), arrow.typeclasses.Traverse((arrow.mtl.instances.traverseFilter.F)))arrow.mtl.instances/arrow.data.-option-t/traverse-filter.html
$dokka.location:arrow.mtl.instances.const.traverseFilter$filter(arrow.Kind((arrow.Kind((arrow.typeclasses.ForConst, arrow.mtl.instances.const.traverseFilter.filter.X)), arrow.mtl.instances.const.traverseFilter.filter.A)), kotlin.Function1((arrow.mtl.instances.const.traverseFilter.filter.A, kotlin.Boolean)))arrow.mtl.instances.const.traverse-filter/arrow.-kind/filter.html
$dokka.location:arrow.mtl.instances.const.traverseFilter$filterA(arrow.Kind((arrow.Kind((arrow.typeclasses.ForConst, arrow.mtl.instances.const.traverseFilter.filterA.X)), arrow.mtl.instances.const.traverseFilter.filterA.A)), kotlin.Function1((arrow.mtl.instances.const.traverseFilter.filterA.A, arrow.Kind((arrow.mtl.instances.const.traverseFilter.filterA.G, kotlin.Boolean)))), arrow.typeclasses.Applicative((arrow.mtl.instances.const.traverseFilter.filterA.G)))arrow.mtl.instances.const.traverse-filter/arrow.-kind/filter-a.html
$dokka.location:arrow.mtl.instances.const.traverseFilter$mapFilter(arrow.Kind((arrow.Kind((arrow.typeclasses.ForConst, arrow.mtl.instances.const.traverseFilter.mapFilter.X)), arrow.mtl.instances.const.traverseFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.const.traverseFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.const.traverseFilter.mapFilter.B)))))arrow.mtl.instances.const.traverse-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.const.traverseFilter$traverseFilter(arrow.Kind((arrow.Kind((arrow.typeclasses.ForConst, arrow.mtl.instances.const.traverseFilter.traverseFilter.X)), arrow.mtl.instances.const.traverseFilter.traverseFilter.A)), arrow.typeclasses.Applicative((arrow.mtl.instances.const.traverseFilter.traverseFilter.G)), kotlin.Function1((arrow.mtl.instances.const.traverseFilter.traverseFilter.A, arrow.Kind((arrow.mtl.instances.const.traverseFilter.traverseFilter.G, arrow.core.Option((arrow.mtl.instances.const.traverseFilter.traverseFilter.B)))))))arrow.mtl.instances.const.traverse-filter/arrow.-kind/traverse-filter.html
$dokka.location:arrow.mtl.instances.const.traverseFilter$traverseFilter(arrow.typeclasses.Const.Companion)arrow.mtl.instances.const.traverse-filter/arrow.typeclasses.-const/traverse-filter.html
$dokka.location:arrow.mtl.instances.function1.monadReader$local(arrow.Kind((arrow.Kind((arrow.core.ForFunction1, arrow.mtl.instances.function1.monadReader.local.I)), arrow.mtl.instances.function1.monadReader.local.A)), kotlin.Function1((arrow.mtl.instances.function1.monadReader.local.I, )))arrow.mtl.instances.function1.monad-reader/arrow.-kind/local.html
$dokka.location:arrow.mtl.instances.function1.monadReader$monadReader(arrow.core.Function1.Companion)arrow.mtl.instances.function1.monad-reader/arrow.core.-function1/monad-reader.html
$dokka.location:arrow.mtl.instances.kleisli.monadReader$local(arrow.Kind((arrow.Kind((arrow.Kind((arrow.data.ForKleisli, arrow.mtl.instances.kleisli.monadReader.local.F)), arrow.mtl.instances.kleisli.monadReader.local.D)), arrow.mtl.instances.kleisli.monadReader.local.A)), kotlin.Function1((arrow.mtl.instances.kleisli.monadReader.local.D, )), arrow.typeclasses.Monad((arrow.mtl.instances.kleisli.monadReader.local.F)))arrow.mtl.instances.kleisli.monad-reader/arrow.-kind/local.html
$dokka.location:arrow.mtl.instances.kleisli.monadReader$monadReader(arrow.data.Kleisli.Companion, arrow.typeclasses.Monad((arrow.mtl.instances.kleisli.monadReader.monadReader.F)))arrow.mtl.instances.kleisli.monad-reader/arrow.data.-kleisli/monad-reader.html
$dokka.location:arrow.mtl.instances.list.functorFilter$collect(kotlin.collections.List((arrow.mtl.instances.list.functorFilter.collect.A)), arrow.core.PartialFunction((arrow.mtl.instances.list.functorFilter.collect.A, arrow.mtl.instances.list.functorFilter.collect.B)))arrow.mtl.instances.list.functor-filter/kotlin.collections.-list/collect.html
$dokka.location:arrow.mtl.instances.list.functorFilter$filter(kotlin.collections.List((arrow.mtl.instances.list.functorFilter.filter.A)), kotlin.Function1((arrow.mtl.instances.list.functorFilter.filter.A, kotlin.Boolean)))arrow.mtl.instances.list.functor-filter/kotlin.collections.-list/filter.html
$dokka.location:arrow.mtl.instances.list.functorFilter$flattenOption(kotlin.collections.List((arrow.core.Option((arrow.mtl.instances.list.functorFilter.flattenOption.A)))))arrow.mtl.instances.list.functor-filter/kotlin.collections.-list/flatten-option.html
$dokka.location:arrow.mtl.instances.list.functorFilter$mapFilter(kotlin.collections.List((arrow.mtl.instances.list.functorFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.list.functorFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.list.functorFilter.mapFilter.B)))))arrow.mtl.instances.list.functor-filter/kotlin.collections.-list/map-filter.html
$dokka.location:arrow.mtl.instances.list.monadCombine$separate(kotlin.collections.List((arrow.Kind((arrow.Kind((arrow.mtl.instances.list.monadCombine.separate.G, arrow.mtl.instances.list.monadCombine.separate.A)), arrow.mtl.instances.list.monadCombine.separate.B)))), arrow.typeclasses.Bifoldable((arrow.mtl.instances.list.monadCombine.separate.G)))arrow.mtl.instances.list.monad-combine/kotlin.collections.-list/separate.html
$dokka.location:arrow.mtl.instances.list.monadCombine$unite(kotlin.collections.List((arrow.Kind((arrow.mtl.instances.list.monadCombine.unite.G, arrow.mtl.instances.list.monadCombine.unite.A)))), arrow.typeclasses.Foldable((arrow.mtl.instances.list.monadCombine.unite.G)))arrow.mtl.instances.list.monad-combine/kotlin.collections.-list/unite.html
$dokka.location:arrow.mtl.instances.list.monadFilter$mapFilter(kotlin.collections.List((arrow.mtl.instances.list.monadFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.list.monadFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.list.monadFilter.mapFilter.B)))))arrow.mtl.instances.list.monad-filter/kotlin.collections.-list/map-filter.html
$dokka.location:arrow.mtl.instances.listk.functorFilter$collect(arrow.Kind((arrow.data.ForListK, arrow.mtl.instances.listk.functorFilter.collect.A)), arrow.core.PartialFunction((arrow.mtl.instances.listk.functorFilter.collect.A, arrow.mtl.instances.listk.functorFilter.collect.B)))arrow.mtl.instances.listk.functor-filter/arrow.-kind/collect.html
$dokka.location:arrow.mtl.instances.listk.functorFilter$filter(arrow.Kind((arrow.data.ForListK, arrow.mtl.instances.listk.functorFilter.filter.A)), kotlin.Function1((arrow.mtl.instances.listk.functorFilter.filter.A, kotlin.Boolean)))arrow.mtl.instances.listk.functor-filter/arrow.-kind/filter.html
$dokka.location:arrow.mtl.instances.listk.functorFilter$flattenOption(arrow.Kind((arrow.data.ForListK, arrow.core.Option((arrow.mtl.instances.listk.functorFilter.flattenOption.A)))))arrow.mtl.instances.listk.functor-filter/arrow.-kind/flatten-option.html
$dokka.location:arrow.mtl.instances.listk.functorFilter$functorFilter(arrow.data.ListK.Companion)arrow.mtl.instances.listk.functor-filter/arrow.data.-list-k/functor-filter.html
$dokka.location:arrow.mtl.instances.listk.functorFilter$mapFilter(arrow.Kind((arrow.data.ForListK, arrow.mtl.instances.listk.functorFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.listk.functorFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.listk.functorFilter.mapFilter.B)))))arrow.mtl.instances.listk.functor-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.listk.monadCombine$monadCombine(arrow.data.ListK.Companion)arrow.mtl.instances.listk.monad-combine/arrow.data.-list-k/monad-combine.html
$dokka.location:arrow.mtl.instances.listk.monadCombine$separate(arrow.Kind((arrow.data.ForListK, arrow.Kind((arrow.Kind((arrow.mtl.instances.listk.monadCombine.separate.G, arrow.mtl.instances.listk.monadCombine.separate.A)), arrow.mtl.instances.listk.monadCombine.separate.B)))), arrow.typeclasses.Bifoldable((arrow.mtl.instances.listk.monadCombine.separate.G)))arrow.mtl.instances.listk.monad-combine/arrow.-kind/separate.html
$dokka.location:arrow.mtl.instances.listk.monadCombine$unite(arrow.Kind((arrow.data.ForListK, arrow.Kind((arrow.mtl.instances.listk.monadCombine.unite.G, arrow.mtl.instances.listk.monadCombine.unite.A)))), arrow.typeclasses.Foldable((arrow.mtl.instances.listk.monadCombine.unite.G)))arrow.mtl.instances.listk.monad-combine/arrow.-kind/unite.html
$dokka.location:arrow.mtl.instances.listk.monadFilter$mapFilter(arrow.Kind((arrow.data.ForListK, arrow.mtl.instances.listk.monadFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.listk.monadFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.listk.monadFilter.mapFilter.B)))))arrow.mtl.instances.listk.monad-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.listk.monadFilter$monadFilter(arrow.data.ListK.Companion)arrow.mtl.instances.listk.monad-filter/arrow.data.-list-k/monad-filter.html
$dokka.location:arrow.mtl.instances.nonemptylist.functorFilter$collect(arrow.Kind((arrow.data.ForNonEmptyList, arrow.mtl.instances.nonemptylist.functorFilter.collect.A)), arrow.core.PartialFunction((arrow.mtl.instances.nonemptylist.functorFilter.collect.A, arrow.mtl.instances.nonemptylist.functorFilter.collect.B)))arrow.mtl.instances.nonemptylist.functor-filter/arrow.-kind/collect.html
$dokka.location:arrow.mtl.instances.nonemptylist.functorFilter$filter(arrow.Kind((arrow.data.ForNonEmptyList, arrow.mtl.instances.nonemptylist.functorFilter.filter.A)), kotlin.Function1((arrow.mtl.instances.nonemptylist.functorFilter.filter.A, kotlin.Boolean)))arrow.mtl.instances.nonemptylist.functor-filter/arrow.-kind/filter.html
$dokka.location:arrow.mtl.instances.nonemptylist.functorFilter$flattenOption(arrow.Kind((arrow.data.ForNonEmptyList, arrow.core.Option((arrow.mtl.instances.nonemptylist.functorFilter.flattenOption.A)))))arrow.mtl.instances.nonemptylist.functor-filter/arrow.-kind/flatten-option.html
$dokka.location:arrow.mtl.instances.nonemptylist.functorFilter$functorFilter(arrow.data.NonEmptyList.Companion)arrow.mtl.instances.nonemptylist.functor-filter/arrow.data.-non-empty-list/functor-filter.html
$dokka.location:arrow.mtl.instances.nonemptylist.functorFilter$mapFilter(arrow.Kind((arrow.data.ForNonEmptyList, arrow.mtl.instances.nonemptylist.functorFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.nonemptylist.functorFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.nonemptylist.functorFilter.mapFilter.B)))))arrow.mtl.instances.nonemptylist.functor-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.option.functorFilter$collect(arrow.Kind((arrow.core.ForOption, arrow.mtl.instances.option.functorFilter.collect.A)), arrow.core.PartialFunction((arrow.mtl.instances.option.functorFilter.collect.A, arrow.mtl.instances.option.functorFilter.collect.B)))arrow.mtl.instances.option.functor-filter/arrow.-kind/collect.html
$dokka.location:arrow.mtl.instances.option.functorFilter$filter(arrow.Kind((arrow.core.ForOption, arrow.mtl.instances.option.functorFilter.filter.A)), kotlin.Function1((arrow.mtl.instances.option.functorFilter.filter.A, kotlin.Boolean)))arrow.mtl.instances.option.functor-filter/arrow.-kind/filter.html
$dokka.location:arrow.mtl.instances.option.functorFilter$flattenOption(arrow.Kind((arrow.core.ForOption, arrow.core.Option((arrow.mtl.instances.option.functorFilter.flattenOption.A)))))arrow.mtl.instances.option.functor-filter/arrow.-kind/flatten-option.html
$dokka.location:arrow.mtl.instances.option.functorFilter$functorFilter(arrow.core.Option.Companion)arrow.mtl.instances.option.functor-filter/arrow.core.-option/functor-filter.html
$dokka.location:arrow.mtl.instances.option.functorFilter$mapFilter(arrow.Kind((arrow.core.ForOption, arrow.mtl.instances.option.functorFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.option.functorFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.option.functorFilter.mapFilter.B)))))arrow.mtl.instances.option.functor-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.option.monadCombine$monadCombine(arrow.core.Option.Companion)arrow.mtl.instances.option.monad-combine/arrow.core.-option/monad-combine.html
$dokka.location:arrow.mtl.instances.option.monadCombine$separate(arrow.Kind((arrow.core.ForOption, arrow.Kind((arrow.Kind((arrow.mtl.instances.option.monadCombine.separate.G, arrow.mtl.instances.option.monadCombine.separate.A)), arrow.mtl.instances.option.monadCombine.separate.B)))), arrow.typeclasses.Bifoldable((arrow.mtl.instances.option.monadCombine.separate.G)))arrow.mtl.instances.option.monad-combine/arrow.-kind/separate.html
$dokka.location:arrow.mtl.instances.option.monadCombine$unite(arrow.Kind((arrow.core.ForOption, arrow.Kind((arrow.mtl.instances.option.monadCombine.unite.G, arrow.mtl.instances.option.monadCombine.unite.A)))), arrow.typeclasses.Foldable((arrow.mtl.instances.option.monadCombine.unite.G)))arrow.mtl.instances.option.monad-combine/arrow.-kind/unite.html
$dokka.location:arrow.mtl.instances.option.monadFilter$mapFilter(arrow.Kind((arrow.core.ForOption, arrow.mtl.instances.option.monadFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.option.monadFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.option.monadFilter.mapFilter.B)))))arrow.mtl.instances.option.monad-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.option.monadFilter$monadFilter(arrow.core.Option.Companion)arrow.mtl.instances.option.monad-filter/arrow.core.-option/monad-filter.html
$dokka.location:arrow.mtl.instances.option.traverseFilter$filter(arrow.Kind((arrow.core.ForOption, arrow.mtl.instances.option.traverseFilter.filter.A)), kotlin.Function1((arrow.mtl.instances.option.traverseFilter.filter.A, kotlin.Boolean)))arrow.mtl.instances.option.traverse-filter/arrow.-kind/filter.html
$dokka.location:arrow.mtl.instances.option.traverseFilter$filterA(arrow.Kind((arrow.core.ForOption, arrow.mtl.instances.option.traverseFilter.filterA.A)), kotlin.Function1((arrow.mtl.instances.option.traverseFilter.filterA.A, arrow.Kind((arrow.mtl.instances.option.traverseFilter.filterA.G, kotlin.Boolean)))), arrow.typeclasses.Applicative((arrow.mtl.instances.option.traverseFilter.filterA.G)))arrow.mtl.instances.option.traverse-filter/arrow.-kind/filter-a.html
$dokka.location:arrow.mtl.instances.option.traverseFilter$mapFilter(arrow.Kind((arrow.core.ForOption, arrow.mtl.instances.option.traverseFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.option.traverseFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.option.traverseFilter.mapFilter.B)))))arrow.mtl.instances.option.traverse-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.option.traverseFilter$traverseFilter(arrow.Kind((arrow.core.ForOption, arrow.mtl.instances.option.traverseFilter.traverseFilter.A)), arrow.typeclasses.Applicative((arrow.mtl.instances.option.traverseFilter.traverseFilter.G)), kotlin.Function1((arrow.mtl.instances.option.traverseFilter.traverseFilter.A, arrow.Kind((arrow.mtl.instances.option.traverseFilter.traverseFilter.G, arrow.core.Option((arrow.mtl.instances.option.traverseFilter.traverseFilter.B)))))))arrow.mtl.instances.option.traverse-filter/arrow.-kind/traverse-filter.html
$dokka.location:arrow.mtl.instances.option.traverseFilter$traverseFilter(arrow.core.Option.Companion)arrow.mtl.instances.option.traverse-filter/arrow.core.-option/traverse-filter.html
$dokka.location:arrow.mtl.instances.optiont.functorFilter$collect(arrow.Kind((arrow.Kind((arrow.data.ForOptionT, arrow.mtl.instances.optiont.functorFilter.collect.F)), arrow.mtl.instances.optiont.functorFilter.collect.A)), arrow.core.PartialFunction((arrow.mtl.instances.optiont.functorFilter.collect.A, arrow.mtl.instances.optiont.functorFilter.collect.B)), arrow.typeclasses.Functor((arrow.mtl.instances.optiont.functorFilter.collect.F)))arrow.mtl.instances.optiont.functor-filter/arrow.-kind/collect.html
$dokka.location:arrow.mtl.instances.optiont.functorFilter$filter(arrow.Kind((arrow.Kind((arrow.data.ForOptionT, arrow.mtl.instances.optiont.functorFilter.filter.F)), arrow.mtl.instances.optiont.functorFilter.filter.A)), kotlin.Function1((arrow.mtl.instances.optiont.functorFilter.filter.A, kotlin.Boolean)), arrow.typeclasses.Functor((arrow.mtl.instances.optiont.functorFilter.filter.F)))arrow.mtl.instances.optiont.functor-filter/arrow.-kind/filter.html
$dokka.location:arrow.mtl.instances.optiont.functorFilter$flattenOption(arrow.Kind((arrow.Kind((arrow.data.ForOptionT, arrow.mtl.instances.optiont.functorFilter.flattenOption.F)), arrow.core.Option((arrow.mtl.instances.optiont.functorFilter.flattenOption.A)))), arrow.typeclasses.Functor((arrow.mtl.instances.optiont.functorFilter.flattenOption.F)))arrow.mtl.instances.optiont.functor-filter/arrow.-kind/flatten-option.html
$dokka.location:arrow.mtl.instances.optiont.functorFilter$functorFilter(arrow.data.OptionT.Companion, arrow.typeclasses.Functor((arrow.mtl.instances.optiont.functorFilter.functorFilter.F)))arrow.mtl.instances.optiont.functor-filter/arrow.data.-option-t/functor-filter.html
$dokka.location:arrow.mtl.instances.optiont.functorFilter$mapFilter(arrow.Kind((arrow.Kind((arrow.data.ForOptionT, arrow.mtl.instances.optiont.functorFilter.mapFilter.F)), arrow.mtl.instances.optiont.functorFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.optiont.functorFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.optiont.functorFilter.mapFilter.B)))), arrow.typeclasses.Functor((arrow.mtl.instances.optiont.functorFilter.mapFilter.F)))arrow.mtl.instances.optiont.functor-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.optiont.traverseFilter$filter(arrow.Kind((arrow.Kind((arrow.data.ForOptionT, arrow.mtl.instances.optiont.traverseFilter.filter.F)), arrow.mtl.instances.optiont.traverseFilter.filter.A)), kotlin.Function1((arrow.mtl.instances.optiont.traverseFilter.filter.A, kotlin.Boolean)), arrow.mtl.typeclasses.TraverseFilter((arrow.mtl.instances.optiont.traverseFilter.filter.F)))arrow.mtl.instances.optiont.traverse-filter/arrow.-kind/filter.html
$dokka.location:arrow.mtl.instances.optiont.traverseFilter$filterA(arrow.Kind((arrow.Kind((arrow.data.ForOptionT, arrow.mtl.instances.optiont.traverseFilter.filterA.F)), arrow.mtl.instances.optiont.traverseFilter.filterA.A)), kotlin.Function1((arrow.mtl.instances.optiont.traverseFilter.filterA.A, arrow.Kind((arrow.mtl.instances.optiont.traverseFilter.filterA.G, kotlin.Boolean)))), arrow.typeclasses.Applicative((arrow.mtl.instances.optiont.traverseFilter.filterA.G)), arrow.mtl.typeclasses.TraverseFilter((arrow.mtl.instances.optiont.traverseFilter.filterA.F)))arrow.mtl.instances.optiont.traverse-filter/arrow.-kind/filter-a.html
$dokka.location:arrow.mtl.instances.optiont.traverseFilter$mapFilter(arrow.Kind((arrow.Kind((arrow.data.ForOptionT, arrow.mtl.instances.optiont.traverseFilter.mapFilter.F)), arrow.mtl.instances.optiont.traverseFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.optiont.traverseFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.optiont.traverseFilter.mapFilter.B)))), arrow.mtl.typeclasses.TraverseFilter((arrow.mtl.instances.optiont.traverseFilter.mapFilter.F)))arrow.mtl.instances.optiont.traverse-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.optiont.traverseFilter$traverseFilter(arrow.Kind((arrow.Kind((arrow.data.ForOptionT, arrow.mtl.instances.optiont.traverseFilter.traverseFilter.F)), arrow.mtl.instances.optiont.traverseFilter.traverseFilter.A)), arrow.typeclasses.Applicative((arrow.mtl.instances.optiont.traverseFilter.traverseFilter.G)), kotlin.Function1((arrow.mtl.instances.optiont.traverseFilter.traverseFilter.A, arrow.Kind((arrow.mtl.instances.optiont.traverseFilter.traverseFilter.G, arrow.core.Option((arrow.mtl.instances.optiont.traverseFilter.traverseFilter.B)))))), arrow.mtl.typeclasses.TraverseFilter((arrow.mtl.instances.optiont.traverseFilter.traverseFilter.F)))arrow.mtl.instances.optiont.traverse-filter/arrow.-kind/traverse-filter.html
$dokka.location:arrow.mtl.instances.optiont.traverseFilter$traverseFilter(arrow.data.OptionT.Companion, arrow.mtl.typeclasses.TraverseFilter((arrow.mtl.instances.optiont.traverseFilter.traverseFilter.F)))arrow.mtl.instances.optiont.traverse-filter/arrow.data.-option-t/traverse-filter.html
$dokka.location:arrow.mtl.instances.sequence.functorFilter$collect(kotlin.sequences.Sequence((arrow.mtl.instances.sequence.functorFilter.collect.A)), arrow.core.PartialFunction((arrow.mtl.instances.sequence.functorFilter.collect.A, arrow.mtl.instances.sequence.functorFilter.collect.B)))arrow.mtl.instances.sequence.functor-filter/kotlin.sequences.-sequence/collect.html
$dokka.location:arrow.mtl.instances.sequence.functorFilter$filter(kotlin.sequences.Sequence((arrow.mtl.instances.sequence.functorFilter.filter.A)), kotlin.Function1((arrow.mtl.instances.sequence.functorFilter.filter.A, kotlin.Boolean)))arrow.mtl.instances.sequence.functor-filter/kotlin.sequences.-sequence/filter.html
$dokka.location:arrow.mtl.instances.sequence.functorFilter$flattenOption(kotlin.sequences.Sequence((arrow.core.Option((arrow.mtl.instances.sequence.functorFilter.flattenOption.A)))))arrow.mtl.instances.sequence.functor-filter/kotlin.sequences.-sequence/flatten-option.html
$dokka.location:arrow.mtl.instances.sequence.functorFilter$mapFilter(kotlin.sequences.Sequence((arrow.mtl.instances.sequence.functorFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.sequence.functorFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.sequence.functorFilter.mapFilter.B)))))arrow.mtl.instances.sequence.functor-filter/kotlin.sequences.-sequence/map-filter.html
$dokka.location:arrow.mtl.instances.sequence.monadCombine$separate(kotlin.sequences.Sequence((arrow.Kind((arrow.Kind((arrow.mtl.instances.sequence.monadCombine.separate.G, arrow.mtl.instances.sequence.monadCombine.separate.A)), arrow.mtl.instances.sequence.monadCombine.separate.B)))), arrow.typeclasses.Bifoldable((arrow.mtl.instances.sequence.monadCombine.separate.G)))arrow.mtl.instances.sequence.monad-combine/kotlin.sequences.-sequence/separate.html
$dokka.location:arrow.mtl.instances.sequence.monadCombine$unite(kotlin.sequences.Sequence((arrow.Kind((arrow.mtl.instances.sequence.monadCombine.unite.G, arrow.mtl.instances.sequence.monadCombine.unite.A)))), arrow.typeclasses.Foldable((arrow.mtl.instances.sequence.monadCombine.unite.G)))arrow.mtl.instances.sequence.monad-combine/kotlin.sequences.-sequence/unite.html
$dokka.location:arrow.mtl.instances.sequence.monadFilter$mapFilter(kotlin.sequences.Sequence((arrow.mtl.instances.sequence.monadFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.sequence.monadFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.sequence.monadFilter.mapFilter.B)))))arrow.mtl.instances.sequence.monad-filter/kotlin.sequences.-sequence/map-filter.html
$dokka.location:arrow.mtl.instances.sequencek.functorFilter$collect(arrow.Kind((arrow.data.ForSequenceK, arrow.mtl.instances.sequencek.functorFilter.collect.A)), arrow.core.PartialFunction((arrow.mtl.instances.sequencek.functorFilter.collect.A, arrow.mtl.instances.sequencek.functorFilter.collect.B)))arrow.mtl.instances.sequencek.functor-filter/arrow.-kind/collect.html
$dokka.location:arrow.mtl.instances.sequencek.functorFilter$filter(arrow.Kind((arrow.data.ForSequenceK, arrow.mtl.instances.sequencek.functorFilter.filter.A)), kotlin.Function1((arrow.mtl.instances.sequencek.functorFilter.filter.A, kotlin.Boolean)))arrow.mtl.instances.sequencek.functor-filter/arrow.-kind/filter.html
$dokka.location:arrow.mtl.instances.sequencek.functorFilter$flattenOption(arrow.Kind((arrow.data.ForSequenceK, arrow.core.Option((arrow.mtl.instances.sequencek.functorFilter.flattenOption.A)))))arrow.mtl.instances.sequencek.functor-filter/arrow.-kind/flatten-option.html
$dokka.location:arrow.mtl.instances.sequencek.functorFilter$functorFilter(arrow.data.SequenceK.Companion)arrow.mtl.instances.sequencek.functor-filter/arrow.data.-sequence-k/functor-filter.html
$dokka.location:arrow.mtl.instances.sequencek.functorFilter$mapFilter(arrow.Kind((arrow.data.ForSequenceK, arrow.mtl.instances.sequencek.functorFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.sequencek.functorFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.sequencek.functorFilter.mapFilter.B)))))arrow.mtl.instances.sequencek.functor-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.sequencek.monadCombine$monadCombine(arrow.data.SequenceK.Companion)arrow.mtl.instances.sequencek.monad-combine/arrow.data.-sequence-k/monad-combine.html
$dokka.location:arrow.mtl.instances.sequencek.monadCombine$separate(arrow.Kind((arrow.data.ForSequenceK, arrow.Kind((arrow.Kind((arrow.mtl.instances.sequencek.monadCombine.separate.G, arrow.mtl.instances.sequencek.monadCombine.separate.A)), arrow.mtl.instances.sequencek.monadCombine.separate.B)))), arrow.typeclasses.Bifoldable((arrow.mtl.instances.sequencek.monadCombine.separate.G)))arrow.mtl.instances.sequencek.monad-combine/arrow.-kind/separate.html
$dokka.location:arrow.mtl.instances.sequencek.monadCombine$unite(arrow.Kind((arrow.data.ForSequenceK, arrow.Kind((arrow.mtl.instances.sequencek.monadCombine.unite.G, arrow.mtl.instances.sequencek.monadCombine.unite.A)))), arrow.typeclasses.Foldable((arrow.mtl.instances.sequencek.monadCombine.unite.G)))arrow.mtl.instances.sequencek.monad-combine/arrow.-kind/unite.html
$dokka.location:arrow.mtl.instances.sequencek.monadFilter$mapFilter(arrow.Kind((arrow.data.ForSequenceK, arrow.mtl.instances.sequencek.monadFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.sequencek.monadFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.sequencek.monadFilter.mapFilter.B)))))arrow.mtl.instances.sequencek.monad-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.sequencek.monadFilter$monadFilter(arrow.data.SequenceK.Companion)arrow.mtl.instances.sequencek.monad-filter/arrow.data.-sequence-k/monad-filter.html
$dokka.location:arrow.mtl.instances.statet.monadCombine$monadCombine(arrow.data.StateT.Companion, arrow.mtl.typeclasses.MonadCombine((arrow.mtl.instances.statet.monadCombine.monadCombine.F)))arrow.mtl.instances.statet.monad-combine/arrow.data.-state-t/monad-combine.html
$dokka.location:arrow.mtl.instances.statet.monadCombine$separate(arrow.Kind((arrow.Kind((arrow.Kind((arrow.data.ForStateT, arrow.mtl.instances.statet.monadCombine.separate.F)), arrow.mtl.instances.statet.monadCombine.separate.S)), arrow.Kind((arrow.Kind((arrow.mtl.instances.statet.monadCombine.separate.G, arrow.mtl.instances.statet.monadCombine.separate.A)), arrow.mtl.instances.statet.monadCombine.separate.B)))), arrow.typeclasses.Bifoldable((arrow.mtl.instances.statet.monadCombine.separate.G)), arrow.mtl.typeclasses.MonadCombine((arrow.mtl.instances.statet.monadCombine.separate.F)))arrow.mtl.instances.statet.monad-combine/arrow.-kind/separate.html
$dokka.location:arrow.mtl.instances.statet.monadCombine$unite(arrow.Kind((arrow.Kind((arrow.Kind((arrow.data.ForStateT, arrow.mtl.instances.statet.monadCombine.unite.F)), arrow.mtl.instances.statet.monadCombine.unite.S)), arrow.Kind((arrow.mtl.instances.statet.monadCombine.unite.G, arrow.mtl.instances.statet.monadCombine.unite.A)))), arrow.typeclasses.Foldable((arrow.mtl.instances.statet.monadCombine.unite.G)), arrow.mtl.typeclasses.MonadCombine((arrow.mtl.instances.statet.monadCombine.unite.F)))arrow.mtl.instances.statet.monad-combine/arrow.-kind/unite.html
$dokka.location:arrow.mtl.instances.statet.monadState$monadState(arrow.data.StateT.Companion, arrow.typeclasses.Monad((arrow.mtl.instances.statet.monadState.monadState.F)))arrow.mtl.instances.statet.monad-state/arrow.data.-state-t/monad-state.html
$dokka.location:arrow.mtl.instances.try.functorFilter$collect(arrow.Kind((arrow.core.ForTry, arrow.mtl.instances.try.functorFilter.collect.A)), arrow.core.PartialFunction((arrow.mtl.instances.try.functorFilter.collect.A, arrow.mtl.instances.try.functorFilter.collect.B)))arrow.mtl.instances.try.functor-filter/arrow.-kind/collect.html
$dokka.location:arrow.mtl.instances.try.functorFilter$filter(arrow.Kind((arrow.core.ForTry, arrow.mtl.instances.try.functorFilter.filter.A)), kotlin.Function1((arrow.mtl.instances.try.functorFilter.filter.A, kotlin.Boolean)))arrow.mtl.instances.try.functor-filter/arrow.-kind/filter.html
$dokka.location:arrow.mtl.instances.try.functorFilter$flattenOption(arrow.Kind((arrow.core.ForTry, arrow.core.Option((arrow.mtl.instances.try.functorFilter.flattenOption.A)))))arrow.mtl.instances.try.functor-filter/arrow.-kind/flatten-option.html
$dokka.location:arrow.mtl.instances.try.functorFilter$functorFilter(arrow.core.Try.Companion)arrow.mtl.instances.try.functor-filter/arrow.core.-try/functor-filter.html
$dokka.location:arrow.mtl.instances.try.functorFilter$mapFilter(arrow.Kind((arrow.core.ForTry, arrow.mtl.instances.try.functorFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.try.functorFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.try.functorFilter.mapFilter.B)))))arrow.mtl.instances.try.functor-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.writert.monadFilter$mapFilter(arrow.Kind((arrow.Kind((arrow.Kind((arrow.data.ForWriterT, arrow.mtl.instances.writert.monadFilter.mapFilter.F)), arrow.mtl.instances.writert.monadFilter.mapFilter.W)), arrow.mtl.instances.writert.monadFilter.mapFilter.A)), kotlin.Function1((arrow.mtl.instances.writert.monadFilter.mapFilter.A, arrow.core.Option((arrow.mtl.instances.writert.monadFilter.mapFilter.B)))), arrow.mtl.typeclasses.MonadFilter((arrow.mtl.instances.writert.monadFilter.mapFilter.F)), arrow.typeclasses.Monoid((arrow.mtl.instances.writert.monadFilter.mapFilter.W)))arrow.mtl.instances.writert.monad-filter/arrow.-kind/map-filter.html
$dokka.location:arrow.mtl.instances.writert.monadFilter$monadFilter(arrow.data.WriterT.Companion, arrow.mtl.typeclasses.MonadFilter((arrow.mtl.instances.writert.monadFilter.monadFilter.F)), arrow.typeclasses.Monoid((arrow.mtl.instances.writert.monadFilter.monadFilter.W)))arrow.mtl.instances.writert.monad-filter/arrow.data.-writer-t/monad-filter.html
$dokka.location:arrow.mtl.instances.writert.monadWriter$censor(arrow.Kind((arrow.Kind((arrow.Kind((arrow.data.ForWriterT, arrow.mtl.instances.writert.monadWriter.censor.F)), arrow.mtl.instances.writert.monadWriter.censor.W)), arrow.mtl.instances.writert.monadWriter.censor.A)), kotlin.Function1((arrow.mtl.instances.writert.monadWriter.censor.W, )), arrow.typeclasses.Monad((arrow.mtl.instances.writert.monadWriter.censor.F)), arrow.typeclasses.Monoid((arrow.mtl.instances.writert.monadWriter.censor.W)))arrow.mtl.instances.writert.monad-writer/arrow.-kind/censor.html
$dokka.location:arrow.mtl.instances.writert.monadWriter$listen(arrow.Kind((arrow.Kind((arrow.Kind((arrow.data.ForWriterT, arrow.mtl.instances.writert.monadWriter.listen.F)), arrow.mtl.instances.writert.monadWriter.listen.W)), arrow.mtl.instances.writert.monadWriter.listen.A)), arrow.typeclasses.Monad((arrow.mtl.instances.writert.monadWriter.listen.F)), arrow.typeclasses.Monoid((arrow.mtl.instances.writert.monadWriter.listen.W)))arrow.mtl.instances.writert.monad-writer/arrow.-kind/listen.html
$dokka.location:arrow.mtl.instances.writert.monadWriter$listens(arrow.Kind((arrow.Kind((arrow.Kind((arrow.data.ForWriterT, arrow.mtl.instances.writert.monadWriter.listens.F)), arrow.mtl.instances.writert.monadWriter.listens.W)), arrow.mtl.instances.writert.monadWriter.listens.A)), kotlin.Function1((arrow.mtl.instances.writert.monadWriter.listens.W, arrow.mtl.instances.writert.monadWriter.listens.B)), arrow.typeclasses.Monad((arrow.mtl.instances.writert.monadWriter.listens.F)), arrow.typeclasses.Monoid((arrow.mtl.instances.writert.monadWriter.listens.W)))arrow.mtl.instances.writert.monad-writer/arrow.-kind/listens.html
$dokka.location:arrow.mtl.instances.writert.monadWriter$monadWriter(arrow.data.WriterT.Companion, arrow.typeclasses.Monad((arrow.mtl.instances.writert.monadWriter.monadWriter.F)), arrow.typeclasses.Monoid((arrow.mtl.instances.writert.monadWriter.monadWriter.W)))arrow.mtl.instances.writert.monad-writer/arrow.data.-writer-t/monad-writer.html
$dokka.location:arrow.mtl.instances.writert.monadWriter$pass(arrow.Kind((arrow.Kind((arrow.Kind((arrow.data.ForWriterT, arrow.mtl.instances.writert.monadWriter.pass.F)), arrow.mtl.instances.writert.monadWriter.pass.W)), arrow.core.Tuple2((kotlin.Function1((, )), arrow.mtl.instances.writert.monadWriter.pass.A)))), arrow.typeclasses.Monad((arrow.mtl.instances.writert.monadWriter.pass.F)), arrow.typeclasses.Monoid((arrow.mtl.instances.writert.monadWriter.pass.W)))arrow.mtl.instances.writert.monad-writer/arrow.-kind/pass.html
arrow.mtl.instances
arrow.mtl.instances.const.traverseFilter
arrow.mtl.instances.function1.monadReader
arrow.mtl.instances.kleisli.monadReader
arrow.mtl.instances.list.functorFilter
arrow.mtl.instances.list.monadCombine
arrow.mtl.instances.list.monadFilter
arrow.mtl.instances.listk.functorFilter
arrow.mtl.instances.listk.monadCombine
arrow.mtl.instances.listk.monadFilter
arrow.mtl.instances.nonemptylist.functorFilter
arrow.mtl.instances.option.functorFilter
arrow.mtl.instances.option.monadCombine
arrow.mtl.instances.option.monadFilter
arrow.mtl.instances.option.traverseFilter
arrow.mtl.instances.optiont.functorFilter
arrow.mtl.instances.optiont.traverseFilter
arrow.mtl.instances.sequence.functorFilter
arrow.mtl.instances.sequence.monadCombine
arrow.mtl.instances.sequence.monadFilter
arrow.mtl.instances.sequencek.functorFilter
arrow.mtl.instances.sequencek.monadCombine
arrow.mtl.instances.sequencek.monadFilter
arrow.mtl.instances.statet.monadCombine
arrow.mtl.instances.statet.monadState
arrow.mtl.instances.try.functorFilter
arrow.mtl.instances.writert.monadFilter
arrow.mtl.instances.writert.monadWriter
arrow.mtl.typeclasses
