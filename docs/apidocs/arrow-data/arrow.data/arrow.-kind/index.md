---
title: arrow.data.arrow.Kind - arrow-data
---

[arrow-data](../../index.html) / [arrow.data](../index.html) / [arrow.Kind](./index.html)

### Extensions for arrow.Kind

| [ap](ap.html) | `fun <E, A, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](ap.html#E)`, `[`A`](ap.html#A)`>.ap(SE: Semigroup<`[`E`](ap.html#E)`>, f: `[`Validated`](../-validated/index.html)`<`[`E`](ap.html#E)`, (`[`A`](ap.html#A)`) -> `[`B`](ap.html#B)`>): `[`Validated`](../-validated/index.html)`<`[`E`](ap.html#E)`, `[`B`](ap.html#B)`>`<br>From Apply: if both the function and this value are Valid, apply the function |
| [combine](combine.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](combine.html#E)`, `[`A`](combine.html#A)`>.combine(SE: Semigroup<`[`E`](combine.html#E)`>, SA: Semigroup<`[`A`](combine.html#A)`>, y: `[`ValidatedOf`](../-validated-of.html)`<`[`E`](combine.html#E)`, `[`A`](combine.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](combine.html#E)`, `[`A`](combine.html#A)`>` |
| [combineK](combine-k.html) | `fun <A> `[`ListKOf`](../-list-k-of.html)`<`[`A`](combine-k.html#A)`>.combineK(y: `[`ListKOf`](../-list-k-of.html)`<`[`A`](combine-k.html#A)`>): `[`ListK`](../-list-k/index.html)`<`[`A`](combine-k.html#A)`>`<br>`fun <A> `[`NonEmptyListOf`](../-non-empty-list-of.html)`<`[`A`](combine-k.html#A)`>.combineK(y: `[`NonEmptyListOf`](../-non-empty-list-of.html)`<`[`A`](combine-k.html#A)`>): `[`NonEmptyList`](../-non-empty-list/index.html)`<`[`A`](combine-k.html#A)`>`<br>`fun <A> `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](combine-k.html#A)`>.combineK(y: `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](combine-k.html#A)`>): `[`SequenceK`](../-sequence-k/index.html)`<`[`A`](combine-k.html#A)`>`<br>`fun <A> `[`SetKOf`](../-set-k-of.html)`<`[`A`](combine-k.html#A)`>.combineK(y: `[`SetKOf`](../-set-k-of.html)`<`[`A`](combine-k.html#A)`>): `[`SetK`](../-set-k/index.html)`<`[`A`](combine-k.html#A)`>`<br>`fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](combine-k.html#E)`, `[`A`](combine-k.html#A)`>.combineK(SE: Semigroup<`[`E`](combine-k.html#E)`>, y: `[`ValidatedOf`](../-validated-of.html)`<`[`E`](combine-k.html#E)`, `[`A`](combine-k.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](combine-k.html#E)`, `[`A`](combine-k.html#A)`>` |
| [coproduct](coproduct.html) | `fun <F, G, A> EitherOf<Kind<`[`F`](coproduct.html#F)`, `[`A`](coproduct.html#A)`>, Kind<`[`G`](coproduct.html#G)`, `[`A`](coproduct.html#A)`>>.coproduct(): `[`Coproduct`](../-coproduct/index.html)`<`[`F`](coproduct.html#F)`, `[`G`](coproduct.html#G)`, `[`A`](coproduct.html#A)`>` |
| [findValid](find-valid.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](find-valid.html#E)`, `[`A`](find-valid.html#A)`>.findValid(SE: Semigroup<`[`E`](find-valid.html#E)`>, that: () -> `[`Validated`](../-validated/index.html)`<`[`E`](find-valid.html#E)`, `[`A`](find-valid.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](find-valid.html#E)`, `[`A`](find-valid.html#A)`>`<br>If `this` is valid return `this`, otherwise if `that` is valid return `that`, otherwise combine the failures. This is similar to [orElse](or-else.html) except that here failures are accumulated. |
| [fix](fix.html) | `fun <F, A, B> `[`CokleisliOf`](../-cokleisli-of.html)`<`[`F`](fix.html#F)`, `[`A`](fix.html#A)`, `[`B`](fix.html#B)`>.fix(): `[`Cokleisli`](../-cokleisli/index.html)`<`[`F`](fix.html#F)`, `[`A`](fix.html#A)`, `[`B`](fix.html#B)`>`<br>`fun <F, G, A> `[`CoproductOf`](../-coproduct-of.html)`<`[`F`](fix.html#F)`, `[`G`](fix.html#G)`, `[`A`](fix.html#A)`>.fix(): `[`Coproduct`](../-coproduct/index.html)`<`[`F`](fix.html#F)`, `[`G`](fix.html#G)`, `[`A`](fix.html#A)`>`<br>`fun <F, G, A> `[`DayOf`](../-day-of.html)`<`[`F`](fix.html#F)`, `[`G`](fix.html#G)`, `[`A`](fix.html#A)`>.fix(): `[`Day`](../-day/index.html)`<`[`F`](fix.html#F)`, `[`G`](fix.html#G)`, `[`A`](fix.html#A)`>`<br>`fun <F, A, B> `[`EitherTOf`](../-either-t-of.html)`<`[`F`](fix.html#F)`, `[`A`](fix.html#A)`, `[`B`](fix.html#B)`>.fix(): `[`EitherT`](../-either-t/index.html)`<`[`F`](fix.html#F)`, `[`A`](fix.html#A)`, `[`B`](fix.html#B)`>`<br>`fun <A, B> `[`IorOf`](../-ior-of.html)`<`[`A`](fix.html#A)`, `[`B`](fix.html#B)`>.fix(): `[`Ior`](../-ior/index.html)`<`[`A`](fix.html#A)`, `[`B`](fix.html#B)`>`<br>`fun <F, D, A> `[`KleisliOf`](../-kleisli-of.html)`<`[`F`](fix.html#F)`, `[`D`](fix.html#D)`, `[`A`](fix.html#A)`>.fix(): `[`Kleisli`](../-kleisli/index.html)`<`[`F`](fix.html#F)`, `[`D`](fix.html#D)`, `[`A`](fix.html#A)`>`<br>`fun <A> `[`ListKOf`](../-list-k-of.html)`<`[`A`](fix.html#A)`>.fix(): `[`ListK`](../-list-k/index.html)`<`[`A`](fix.html#A)`>`<br>`fun <K, A> `[`MapKOf`](../-map-k-of.html)`<`[`K`](fix.html#K)`, `[`A`](fix.html#A)`>.fix(): `[`MapK`](../-map-k/index.html)`<`[`K`](fix.html#K)`, `[`A`](fix.html#A)`>`<br>`fun <E, V> `[`MooreOf`](../-moore-of.html)`<`[`E`](fix.html#E)`, `[`V`](fix.html#V)`>.fix(): `[`Moore`](../-moore/index.html)`<`[`E`](fix.html#E)`, `[`V`](fix.html#V)`>`<br>`fun <A> `[`NonEmptyListOf`](../-non-empty-list-of.html)`<`[`A`](fix.html#A)`>.fix(): `[`NonEmptyList`](../-non-empty-list/index.html)`<`[`A`](fix.html#A)`>`<br>`fun <F, A> `[`OptionTOf`](../-option-t-of.html)`<`[`F`](fix.html#F)`, `[`A`](fix.html#A)`>.fix(): `[`OptionT`](../-option-t/index.html)`<`[`F`](fix.html#F)`, `[`A`](fix.html#A)`>`<br>`fun <A> `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](fix.html#A)`>.fix(): `[`SequenceK`](../-sequence-k/index.html)`<`[`A`](fix.html#A)`>`<br>`fun <A> `[`SetKOf`](../-set-k-of.html)`<`[`A`](fix.html#A)`>.fix(): `[`SetK`](../-set-k/index.html)`<`[`A`](fix.html#A)`>`<br>`fun <A : `[`Comparable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparable/index.html)`<`[`A`](fix.html#A)`>, B> `[`SortedMapKOf`](../-sorted-map-k-of.html)`<`[`A`](fix.html#A)`, `[`B`](fix.html#B)`>.fix(): `[`SortedMapK`](../-sorted-map-k/index.html)`<`[`A`](fix.html#A)`, `[`B`](fix.html#B)`>`<br>`fun <F, S, A> `[`StateTOf`](../-state-t-of.html)`<`[`F`](fix.html#F)`, `[`S`](fix.html#S)`, `[`A`](fix.html#A)`>.fix(): `[`StateT`](../-state-t/index.html)`<`[`F`](fix.html#F)`, `[`S`](fix.html#S)`, `[`A`](fix.html#A)`>`<br>`fun <S, V> `[`StoreOf`](../-store-of.html)`<`[`S`](fix.html#S)`, `[`V`](fix.html#V)`>.fix(): `[`Store`](../-store/index.html)`<`[`S`](fix.html#S)`, `[`V`](fix.html#V)`>`<br>`fun <F, G, V> `[`SumOf`](../-sum-of.html)`<`[`F`](fix.html#F)`, `[`G`](fix.html#G)`, `[`V`](fix.html#V)`>.fix(): `[`Sum`](../-sum/index.html)`<`[`F`](fix.html#F)`, `[`G`](fix.html#G)`, `[`V`](fix.html#V)`>`<br>`fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](fix.html#E)`, `[`A`](fix.html#A)`>.fix(): `[`Validated`](../-validated/index.html)`<`[`E`](fix.html#E)`, `[`A`](fix.html#A)`>`<br>`fun <F, W, A> `[`WriterTOf`](../-writer-t-of.html)`<`[`F`](fix.html#F)`, `[`W`](fix.html#W)`, `[`A`](fix.html#A)`>.fix(): `[`WriterT`](../-writer-t/index.html)`<`[`F`](fix.html#F)`, `[`W`](fix.html#W)`, `[`A`](fix.html#A)`>` |
| [flatten](flatten.html) | `fun <F, D, A> `[`KleisliOf`](../-kleisli-of.html)`<`[`F`](flatten.html#F)`, `[`D`](flatten.html#D)`, `[`Kleisli`](../-kleisli/index.html)`<`[`F`](flatten.html#F)`, `[`D`](flatten.html#D)`, `[`A`](flatten.html#A)`>>.flatten(MF: Monad<`[`F`](flatten.html#F)`>): `[`Kleisli`](../-kleisli/index.html)`<`[`F`](flatten.html#F)`, `[`D`](flatten.html#D)`, `[`A`](flatten.html#A)`>`<br>Flatten nested [Kleisli](../-kleisli/index.html) arrows. |
| [getOrElse](get-or-else.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](get-or-else.html#E)`, `[`B`](get-or-else.html#B)`>.getOrElse(default: () -> `[`B`](get-or-else.html#B)`): `[`B`](get-or-else.html#B)<br>Return the Valid value, or the default if Invalid |
| [handleLeftWith](handle-left-with.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](handle-left-with.html#E)`, `[`A`](handle-left-with.html#A)`>.handleLeftWith(f: (`[`E`](handle-left-with.html#E)`) -> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](handle-left-with.html#E)`, `[`A`](handle-left-with.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](handle-left-with.html#E)`, `[`A`](handle-left-with.html#A)`>` |
| [mapFilter](map-filter.html) | `fun <F, A, B> `[`OptionTOf`](../-option-t-of.html)`<`[`F`](map-filter.html#F)`, `[`A`](map-filter.html#A)`>.mapFilter(FF: Functor<`[`F`](map-filter.html#F)`>, f: (`[`A`](map-filter.html#A)`) -> Option<`[`B`](map-filter.html#B)`>): `[`OptionT`](../-option-t/index.html)`<`[`F`](map-filter.html#F)`, `[`B`](map-filter.html#B)`>` |
| [orElse](or-else.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](or-else.html#E)`, `[`A`](or-else.html#A)`>.orElse(default: () -> `[`Validated`](../-validated/index.html)`<`[`E`](or-else.html#E)`, `[`A`](or-else.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](or-else.html#E)`, `[`A`](or-else.html#A)`>`<br>Return this if it is Valid, or else fall back to the given default. The functionality is similar to that of [findValid](find-valid.html) except for failure accumulation, where here only the error on the right is preserved and the error on the left is ignored. |
| [orNull](or-null.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](or-null.html#E)`, `[`B`](or-null.html#B)`>.orNull(): `[`B`](or-null.html#B)`?`<br>Return the Valid value, or null if Invalid |
| [runM](run-m.html) | `fun <F, S, A> `[`StateTOf`](../-state-t-of.html)`<`[`F`](run-m.html#F)`, `[`S`](run-m.html#S)`, `[`A`](run-m.html#A)`>.runM(MF: Monad<`[`F`](run-m.html#F)`>, initial: `[`S`](run-m.html#S)`): Kind<`[`F`](run-m.html#F)`, Tuple2<`[`S`](run-m.html#S)`, `[`A`](run-m.html#A)`>>`<br>Run the stateful computation within the context `F`. |
| [sequence](sequence.html) | `fun <F, G, A, H> `[`CoproductOf`](../-coproduct-of.html)`<`[`F`](sequence.html#F)`, `[`G`](sequence.html#G)`, Kind<`[`H`](sequence.html#H)`, `[`A`](sequence.html#A)`>>.sequence(HA: Applicative<`[`H`](sequence.html#H)`>, FT: Traverse<`[`F`](sequence.html#F)`>, GT: Traverse<`[`G`](sequence.html#G)`>): Kind<`[`H`](sequence.html#H)`, `[`Coproduct`](../-coproduct/index.html)`<`[`F`](sequence.html#F)`, `[`G`](sequence.html#G)`, `[`A`](sequence.html#A)`>>`<br>`fun <A, B, G> `[`IorOf`](../-ior-of.html)`<`[`A`](sequence.html#A)`, Kind<`[`G`](sequence.html#G)`, `[`B`](sequence.html#B)`>>.sequence(GA: Applicative<`[`G`](sequence.html#G)`>): Kind<`[`G`](sequence.html#G)`, `[`Ior`](../-ior/index.html)`<`[`A`](sequence.html#A)`, `[`B`](sequence.html#B)`>>`<br>`fun <K, V, G> `[`MapKOf`](../-map-k-of.html)`<`[`K`](sequence.html#K)`, Kind<`[`G`](sequence.html#G)`, `[`V`](sequence.html#V)`>>.sequence(GA: Applicative<`[`G`](sequence.html#G)`>): Kind<`[`G`](sequence.html#G)`, `[`MapK`](../-map-k/index.html)`<`[`K`](sequence.html#K)`, `[`V`](sequence.html#V)`>>`<br>`fun <A, G> `[`NonEmptyListOf`](../-non-empty-list-of.html)`<Kind<`[`G`](sequence.html#G)`, `[`A`](sequence.html#A)`>>.sequence(GA: Applicative<`[`G`](sequence.html#G)`>): Kind<`[`G`](sequence.html#G)`, `[`NonEmptyList`](../-non-empty-list/index.html)`<`[`A`](sequence.html#A)`>>`<br>`fun <A, G> `[`SequenceKOf`](../-sequence-k-of.html)`<Kind<`[`G`](sequence.html#G)`, `[`A`](sequence.html#A)`>>.sequence(GA: Applicative<`[`G`](sequence.html#G)`>): Kind<`[`G`](sequence.html#G)`, `[`SequenceK`](../-sequence-k/index.html)`<`[`A`](sequence.html#A)`>>`<br>`fun <K : `[`Comparable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparable/index.html)`<`[`K`](sequence.html#K)`>, V, G> `[`SortedMapKOf`](../-sorted-map-k-of.html)`<`[`K`](sequence.html#K)`, Kind<`[`G`](sequence.html#G)`, `[`V`](sequence.html#V)`>>.sequence(GA: Applicative<`[`G`](sequence.html#G)`>): Kind<`[`G`](sequence.html#G)`, `[`SortedMapK`](../-sorted-map-k/index.html)`<`[`K`](sequence.html#K)`, `[`V`](sequence.html#V)`>>`<br>`fun <G, E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](sequence.html#E)`, Kind<`[`G`](sequence.html#G)`, `[`A`](sequence.html#A)`>>.sequence(GA: Applicative<`[`G`](sequence.html#G)`>): Kind<`[`G`](sequence.html#G)`, `[`Validated`](../-validated/index.html)`<`[`E`](sequence.html#E)`, `[`A`](sequence.html#A)`>>` |
| [stateT](state-t.html) | `fun <F, S, A> `[`StateTFunOf`](../-state-t-fun-of.html)`<`[`F`](state-t.html#F)`, `[`S`](state-t.html#S)`, `[`A`](state-t.html#A)`>.stateT(): `[`StateT`](../-state-t/index.html)`<`[`F`](state-t.html#F)`, `[`S`](state-t.html#S)`, `[`A`](state-t.html#A)`>`<br>Wrap the function with [StateT](../-state-t/index.html). |
| [toIor](to-ior.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](to-ior.html#E)`, `[`A`](to-ior.html#A)`>.toIor(): `[`Ior`](../-ior/index.html)`<`[`E`](to-ior.html#E)`, `[`A`](to-ior.html#A)`>`<br>Converts the value to an Ior&lt;E, A&gt; |
| [toList](to-list.html) | `fun <A> `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](to-list.html#A)`>.toList(): `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`A`](to-list.html#A)`>` |
| [toState](to-state.html) | `fun <S, A> `[`StateFunOf`](../-state-fun-of.html)`<`[`S`](to-state.html#S)`, `[`A`](to-state.html#A)`>.toState(): `[`State`](../-state.html)`<`[`S`](to-state.html#S)`, `[`A`](to-state.html#A)`>`<br>Syntax for constructing a `StateT<ForId, S, A>` from a function `(S) -> Tuple2<S, A>` |
| [traverse](traverse.html) | `fun <G, E, A, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](traverse.html#E)`, `[`A`](traverse.html#A)`>.traverse(GA: Applicative<`[`G`](traverse.html#G)`>, f: (`[`A`](traverse.html#A)`) -> Kind<`[`G`](traverse.html#G)`, `[`B`](traverse.html#B)`>): Kind<`[`G`](traverse.html#G)`, `[`Validated`](../-validated/index.html)`<`[`E`](traverse.html#E)`, `[`B`](traverse.html#B)`>>` |
| [value](value.html) | `fun <F, A, B> `[`EitherTOf`](../-either-t-of.html)`<`[`F`](value.html#F)`, `[`A`](value.html#A)`, `[`B`](value.html#B)`>.value(): Kind<`[`F`](value.html#F)`, Either<`[`A`](value.html#A)`, `[`B`](value.html#B)`>>`<br>`fun <F, A> `[`OptionTOf`](../-option-t-of.html)`<`[`F`](value.html#F)`, `[`A`](value.html#A)`>.value(): Kind<`[`F`](value.html#F)`, Option<`[`A`](value.html#A)`>>`<br>`fun <F, W, A> `[`WriterTOf`](../-writer-t-of.html)`<`[`F`](value.html#F)`, `[`W`](value.html#W)`, `[`A`](value.html#A)`>.value(): Kind<`[`F`](value.html#F)`, Tuple2<`[`W`](value.html#W)`, `[`A`](value.html#A)`>>` |
| [valueOr](value-or.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](value-or.html#E)`, `[`B`](value-or.html#B)`>.valueOr(f: (`[`E`](value-or.html#E)`) -> `[`B`](value-or.html#B)`): `[`B`](value-or.html#B)<br>Return the Valid value, or the result of f if Invalid |

