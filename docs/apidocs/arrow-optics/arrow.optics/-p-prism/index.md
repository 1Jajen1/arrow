---
title: PPrism - arrow-optics
---

[arrow-optics](../../index.html) / [arrow.optics](../index.html) / [PPrism](./index.html)

# PPrism

`@higherkind interface PPrism<S, T, A, B> : `[`PPrismOf`](../-p-prism-of.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>`

A [Prism](../-prism.html) is a loss less invertible optic that can look into a structure and optionally find its focus.
Mostly used for finding a focus that is only present under certain conditions i.e. list head Prism&lt;List, Int&gt;

A (polymorphic) [PPrism](./index.html) is useful when setting or modifying a value for a polymorphic sum type
i.e. PPrism&lt;Try, Try, String, Int&gt;

A [PPrism](./index.html) gathers the two concepts of pattern matching and constructor and thus can be seen as a pair of functions:

* `getOrModify: A -> Either<A, B>` meaning it returns the focus of a [PPrism](./index.html) OR the original value
* `reverseGet : B -> A` meaning we can construct the source type of a [PPrism](./index.html) from a focus `B`

### Parameters

`S` - the source of a [PPrism](./index.html)

`T` - the modified source of a [PPrism](./index.html)

`A` - the focus of a [PPrism](./index.html)

`B` - the modified focus of a [PPrism](./index.html)

### Functions

| [asFold](as-fold.html) | `open fun asFold(): `[`Fold`](../-fold/index.html)`<`[`S`](index.html#S)`, `[`A`](index.html#A)`>`<br>View a [PPrism](./index.html) as a [Fold](../-fold/index.html) |
| [asOptional](as-optional.html) | `open fun asOptional(): `[`POptional`](../-p-optional/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>`<br>View a [PPrism](./index.html) as an [POptional](../-p-optional/index.html) |
| [asSetter](as-setter.html) | `open fun asSetter(): `[`PSetter`](../-p-setter/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>`<br>View a [PPrism](./index.html) as a [PSetter](../-p-setter/index.html) |
| [asTraversal](as-traversal.html) | `open fun asTraversal(): `[`PTraversal`](../-p-traversal/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>`<br>View a [PPrism](./index.html) as a [PTraversal](../-p-traversal/index.html) |
| [compose](compose.html) | `open infix fun <C, D> compose(other: `[`PPrism`](./index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PPrism`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PPrism](./index.html) with another [PPrism](./index.html)`open infix fun <C, D> compose(other: `[`PIso`](../-p-iso/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PPrism`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose an [Iso](../-iso.html) as an [PPrism](./index.html)`open infix fun <C, D> compose(other: `[`POptional`](../-p-optional/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`POptional`](../-p-optional/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PPrism](./index.html) with a [POptional](../-p-optional/index.html)`open infix fun <C, D> compose(other: `[`PLens`](../-p-lens/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`POptional`](../-p-optional/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PPrism](./index.html) with a [PLens](../-p-lens/index.html)`open infix fun <C, D> compose(other: `[`PSetter`](../-p-setter/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PSetter`](../-p-setter/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PPrism](./index.html) with a [PSetter](../-p-setter/index.html)`open infix fun <C> compose(other: `[`Fold`](../-fold/index.html)`<`[`A`](index.html#A)`, `[`C`](compose.html#C)`>): `[`Fold`](../-fold/index.html)`<`[`S`](index.html#S)`, `[`C`](compose.html#C)`>`<br>Compose a [PPrism](./index.html) with a [Fold](../-fold/index.html)`open infix fun <C, D> compose(other: `[`PTraversal`](../-p-traversal/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PTraversal`](../-p-traversal/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PPrism](./index.html) with a [PTraversal](../-p-traversal/index.html) |
| [first](first.html) | `open fun <C> first(): `[`PPrism`](./index.html)`<Tuple2<`[`S`](index.html#S)`, `[`C`](first.html#C)`>, Tuple2<`[`T`](index.html#T)`, `[`C`](first.html#C)`>, Tuple2<`[`A`](index.html#A)`, `[`C`](first.html#C)`>, Tuple2<`[`B`](index.html#B)`, `[`C`](first.html#C)`>>`<br>Create a product of the [PPrism](./index.html) and a type [C](first.html#C) |
| [getOption](get-option.html) | `open fun getOption(s: `[`S`](index.html#S)`): Option<`[`A`](index.html#A)`>`<br>Get the focus or [Option.None](#) if focus cannot be seen |
| [getOrModify](get-or-modify.html) | `abstract fun getOrModify(s: `[`S`](index.html#S)`): Either<`[`T`](index.html#T)`, `[`A`](index.html#A)`>` |
| [isEmpty](is-empty.html) | `open fun isEmpty(s: `[`S`](index.html#S)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if no focus can be seen by the [PPrism](./index.html) |
| [liftF](lift-f.html) | `open fun <F> liftF(FA: Applicative<`[`F`](lift-f.html#F)`>, f: (`[`A`](index.html#A)`) -> Kind<`[`F`](lift-f.html#F)`, `[`B`](index.html#B)`>): (`[`S`](index.html#S)`) -> Kind<`[`F`](lift-f.html#F)`, `[`T`](index.html#T)`>`<br>Modify the focus of a [PPrism](./index.html) with an [Applicative](#) function |
| [modifyF](modify-f.html) | `open fun <F> modifyF(FA: Applicative<`[`F`](modify-f.html#F)`>, s: `[`S`](index.html#S)`, f: (`[`A`](index.html#A)`) -> Kind<`[`F`](modify-f.html#F)`, `[`B`](index.html#B)`>): Kind<`[`F`](modify-f.html#F)`, `[`T`](index.html#T)`>`<br>Modify the focus of a [PPrism](./index.html) with an [Applicative](#) function |
| [nonEmpty](non-empty.html) | `open fun nonEmpty(s: `[`S`](index.html#S)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if a focus can be seen by the [PPrism](./index.html) |
| [plus](plus.html) | `open operator fun <C, D> plus(other: `[`PPrism`](./index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PPrism`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>Plus operator overload to compose lenses`open operator fun <C, D> plus(other: `[`POptional`](../-p-optional/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`POptional`](../-p-optional/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C, D> plus(other: `[`PLens`](../-p-lens/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`POptional`](../-p-optional/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C, D> plus(other: `[`PIso`](../-p-iso/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PPrism`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C, D> plus(other: `[`PSetter`](../-p-setter/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PSetter`](../-p-setter/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C> plus(other: `[`Fold`](../-fold/index.html)`<`[`A`](index.html#A)`, `[`C`](plus.html#C)`>): `[`Fold`](../-fold/index.html)`<`[`S`](index.html#S)`, `[`C`](plus.html#C)`>`<br>`open operator fun <C, D> plus(other: `[`PTraversal`](../-p-traversal/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PTraversal`](../-p-traversal/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>` |
| [reverseGet](reverse-get.html) | `abstract fun reverseGet(b: `[`B`](index.html#B)`): `[`T`](index.html#T) |
| [second](second.html) | `open fun <C> second(): `[`PPrism`](./index.html)`<Tuple2<`[`C`](second.html#C)`, `[`S`](index.html#S)`>, Tuple2<`[`C`](second.html#C)`, `[`T`](index.html#T)`>, Tuple2<`[`C`](second.html#C)`, `[`A`](index.html#A)`>, Tuple2<`[`C`](second.html#C)`, `[`B`](index.html#B)`>>`<br>Create a product of a type [C](second.html#C) and the [PPrism](./index.html) |
| [set](set.html) | `open fun set(s: `[`S`](index.html#S)`, b: `[`B`](index.html#B)`): `[`T`](index.html#T)<br>Set the focus of a [PPrism](./index.html) with a value |
| [setOption](set-option.html) | `open fun setOption(s: `[`S`](index.html#S)`, b: `[`B`](index.html#B)`): Option<`[`T`](index.html#T)`>`<br>Set the focus of a [PPrism](./index.html) with a value |

### Companion Object Functions

| [id](id.html) | `fun <S> id(): `[`PPrism`](./index.html)`<`[`S`](id.html#S)`, `[`S`](id.html#S)`, `[`S`](id.html#S)`, `[`S`](id.html#S)`>` |
| [invoke](invoke.html) | `operator fun <S, T, A, B> invoke(getOrModify: (`[`S`](invoke.html#S)`) -> Either<`[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`>, reverseGet: (`[`B`](invoke.html#B)`) -> `[`T`](invoke.html#T)`): `[`PPrism`](./index.html)`<`[`S`](invoke.html#S)`, `[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`, `[`B`](invoke.html#B)`>`<br>Invoke operator overload to create a [PPrism](./index.html) of type `S` with focus `A`. Can also be used to construct [Prism](../-prism.html)`operator fun <S, A> invoke(partialFunction: PartialFunction<`[`S`](invoke.html#S)`, `[`A`](invoke.html#A)`>, reverseGet: (`[`A`](invoke.html#A)`) -> `[`S`](invoke.html#S)`): `[`Prism`](../-prism.html)`<`[`S`](invoke.html#S)`, `[`A`](invoke.html#A)`>`<br>Invoke operator overload to create a [PPrism](./index.html) of type `S` with focus `A` with a [PartialFunction](#) Can also be used to construct [Prism](../-prism.html) |
| [only](only.html) | `fun <A> only(a: `[`A`](only.html#A)`, EQA: Eq<`[`A`](only.html#A)`>): `[`Prism`](../-prism.html)`<`[`A`](only.html#A)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>A [PPrism](./index.html) that checks for equality with a given value [a](only.html#arrow.optics.PPrism.Companion$only(arrow.optics.PPrism.Companion.only.A, arrow.typeclasses.Eq((arrow.optics.PPrism.Companion.only.A)))/a) |

### Extension Properties

| [every](../../arrow.optics.typeclasses/-each/every.html) | `open val <T> `[`Prism`](../-prism.html)`<`[`T`](../../arrow.optics.typeclasses/-each/every.html#T)`, `[`S`](../../arrow.optics.typeclasses/-each/index.html#S)`>.every: `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.typeclasses/-each/every.html#T)`, `[`A`](../../arrow.optics.typeclasses/-each/index.html#A)`>`<br>DSL to compose [Each](../../arrow.optics.typeclasses/-each/index.html) with a [Prism](../-prism.html) for a structure [S](../../arrow.optics.typeclasses/-each/index.html#S) to see all its foci [A](../../arrow.optics.typeclasses/-each/index.html#A) |
| [some](../../arrow.optics.dsl/some.html) | `val <T, S> `[`Prism`](../-prism.html)`<`[`T`](../../arrow.optics.dsl/some.html#T)`, Option<`[`S`](../../arrow.optics.dsl/some.html#S)`>>.some: `[`Prism`](../-prism.html)`<`[`T`](../../arrow.optics.dsl/some.html#T)`, `[`S`](../../arrow.optics.dsl/some.html#S)`>`<br>DSL to compose a [Prism](../-prism.html) with focus [arrow.core.Some](#) with a [Prism](../-prism.html) with a focus of [Option](#)&lt;[S](../../arrow.optics.dsl/some.html#S)&gt; |

### Extension Functions

| [all](../all.html) | `fun <S, T, A, B> `[`PPrism`](./index.html)`<`[`S`](../all.html#S)`, `[`T`](../all.html#T)`, `[`A`](../all.html#A)`, `[`B`](../all.html#B)`>.all(s: `[`S`](../all.html#S)`, p: (`[`A`](../all.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if there is no focus or the focus satisfies the predicate |
| [at](../../arrow.optics.dsl/at.html) | `fun <T, S, I, A> `[`Prism`](../-prism.html)`<`[`T`](../../arrow.optics.dsl/at.html#T)`, `[`S`](../../arrow.optics.dsl/at.html#S)`>.at(AT: `[`At`](../../arrow.optics.typeclasses/-at/index.html)`<`[`S`](../../arrow.optics.dsl/at.html#S)`, `[`I`](../../arrow.optics.dsl/at.html#I)`, `[`A`](../../arrow.optics.dsl/at.html#A)`>, i: `[`I`](../../arrow.optics.dsl/at.html#I)`): `[`Optional`](../-optional.html)`<`[`T`](../../arrow.optics.dsl/at.html#T)`, `[`A`](../../arrow.optics.dsl/at.html#A)`>`<br>DSL to compose [At](../../arrow.optics.typeclasses/-at/index.html) with a [Prism](../-prism.html) for a structure [S](../../arrow.optics.dsl/at.html#S) to focus in on [A](../../arrow.optics.dsl/at.html#A) at given index [I](../../arrow.optics.dsl/at.html#I). |
| [every](../../arrow.optics.dsl/every.html) | `fun <T, S, A> `[`Prism`](../-prism.html)`<`[`T`](../../arrow.optics.dsl/every.html#T)`, `[`S`](../../arrow.optics.dsl/every.html#S)`>.every(EA: `[`Each`](../../arrow.optics.typeclasses/-each/index.html)`<`[`S`](../../arrow.optics.dsl/every.html#S)`, `[`A`](../../arrow.optics.dsl/every.html#A)`>): `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.dsl/every.html#T)`, `[`A`](../../arrow.optics.dsl/every.html#A)`>`<br>DSL to compose [Each](../../arrow.optics.typeclasses/-each/index.html) with a [Prism](../-prism.html) for a structure [S](../../arrow.optics.dsl/every.html#S) to see all its foci [A](../../arrow.optics.dsl/every.html#A) |
| [exist](../exist.html) | `fun <S, T, A, B> `[`PPrism`](./index.html)`<`[`S`](../exist.html#S)`, `[`T`](../exist.html#T)`, `[`A`](../exist.html#A)`, `[`B`](../exist.html#B)`>.exist(s: `[`S`](../exist.html#S)`, p: (`[`A`](../exist.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if there is a focus and it satisfies the predicate |
| [find](../find.html) | `fun <S, T, A, B> `[`PPrism`](./index.html)`<`[`S`](../find.html#S)`, `[`T`](../find.html#T)`, `[`A`](../find.html#A)`, `[`B`](../find.html#B)`>.find(s: `[`S`](../find.html#S)`, p: (`[`A`](../find.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): Option<`[`A`](../find.html#A)`>`<br>Find the focus that satisfies the predicate |
| [index](../../arrow.optics.dsl/--index--.html) | `fun <T, S, I, A> `[`Prism`](../-prism.html)`<`[`T`](../../arrow.optics.dsl/--index--.html#T)`, `[`S`](../../arrow.optics.dsl/--index--.html#S)`>.index(ID: `[`Index`](../../arrow.optics.typeclasses/-index/index.html)`<`[`S`](../../arrow.optics.dsl/--index--.html#S)`, `[`I`](../../arrow.optics.dsl/--index--.html#I)`, `[`A`](../../arrow.optics.dsl/--index--.html#A)`>, i: `[`I`](../../arrow.optics.dsl/--index--.html#I)`): `[`Optional`](../-optional.html)`<`[`T`](../../arrow.optics.dsl/--index--.html#T)`, `[`A`](../../arrow.optics.dsl/--index--.html#A)`>`<br>DSL to compose [Index](../../arrow.optics.typeclasses/-index/index.html) with a [Prism](../-prism.html) for a structure [S](../../arrow.optics.dsl/--index--.html#S) to focus in on [A](../../arrow.optics.dsl/--index--.html#A) at given index [I](../../arrow.optics.dsl/--index--.html#I) |
| [left](../left.html) | `fun <S, T, A, B, C> `[`PPrism`](./index.html)`<`[`S`](../left.html#S)`, `[`T`](../left.html#T)`, `[`A`](../left.html#A)`, `[`B`](../left.html#B)`>.left(): `[`PPrism`](./index.html)`<Either<`[`S`](../left.html#S)`, `[`C`](../left.html#C)`>, Either<`[`T`](../left.html#T)`, `[`C`](../left.html#C)`>, Either<`[`A`](../left.html#A)`, `[`C`](../left.html#C)`>, Either<`[`B`](../left.html#B)`, `[`C`](../left.html#C)`>>`<br>Create a sum of the [PPrism](./index.html) and a type [C](../left.html#C) |
| [lift](../lift.html) | `fun <S, T, A, B> `[`PPrism`](./index.html)`<`[`S`](../lift.html#S)`, `[`T`](../lift.html#T)`, `[`A`](../lift.html#A)`, `[`B`](../lift.html#B)`>.lift(f: (`[`A`](../lift.html#A)`) -> `[`B`](../lift.html#B)`): (`[`S`](../lift.html#S)`) -> `[`T`](../lift.html#T)<br>Lift a function [f](../lift.html#arrow.optics$lift(arrow.optics.PPrism((arrow.optics.lift.S, arrow.optics.lift.T, arrow.optics.lift.A, arrow.optics.lift.B)), kotlin.Function1((arrow.optics.lift.A, arrow.optics.lift.B)))/f): `(A) -> B to the context of `S`: `(S) -&gt; T` |
| [liftOption](../lift-option.html) | `fun <S, T, A, B> `[`PPrism`](./index.html)`<`[`S`](../lift-option.html#S)`, `[`T`](../lift-option.html#T)`, `[`A`](../lift-option.html#A)`, `[`B`](../lift-option.html#B)`>.liftOption(f: (`[`A`](../lift-option.html#A)`) -> `[`B`](../lift-option.html#B)`): (`[`S`](../lift-option.html#S)`) -> Option<`[`T`](../lift-option.html#T)`>`<br>Lift a function [f](../lift-option.html#arrow.optics$liftOption(arrow.optics.PPrism((arrow.optics.liftOption.S, arrow.optics.liftOption.T, arrow.optics.liftOption.A, arrow.optics.liftOption.B)), kotlin.Function1((arrow.optics.liftOption.A, arrow.optics.liftOption.B)))/f): `(A) -> B to the context of `S`: `(S) -&gt; Option` |
| [modify](../modify.html) | `fun <S, T, A, B> `[`PPrism`](./index.html)`<`[`S`](../modify.html#S)`, `[`T`](../modify.html#T)`, `[`A`](../modify.html#A)`, `[`B`](../modify.html#B)`>.modify(s: `[`S`](../modify.html#S)`, f: (`[`A`](../modify.html#A)`) -> `[`B`](../modify.html#B)`): `[`T`](../modify.html#T)<br>Modify the focus of a [PPrism](./index.html) with a function |
| [modifyOption](../modify-option.html) | `fun <S, T, A, B> `[`PPrism`](./index.html)`<`[`S`](../modify-option.html#S)`, `[`T`](../modify-option.html#T)`, `[`A`](../modify-option.html#A)`, `[`B`](../modify-option.html#B)`>.modifyOption(s: `[`S`](../modify-option.html#S)`, f: (`[`A`](../modify-option.html#A)`) -> `[`B`](../modify-option.html#B)`): Option<`[`T`](../modify-option.html#T)`>`<br>Modify the focus of a [PPrism](./index.html) with a function |
| [right](../right.html) | `fun <S, T, A, B, C> `[`PPrism`](./index.html)`<`[`S`](../right.html#S)`, `[`T`](../right.html#T)`, `[`A`](../right.html#A)`, `[`B`](../right.html#B)`>.right(): `[`PPrism`](./index.html)`<Either<`[`C`](../right.html#C)`, `[`S`](../right.html#S)`>, Either<`[`C`](../right.html#C)`, `[`T`](../right.html#T)`>, Either<`[`C`](../right.html#C)`, `[`A`](../right.html#A)`>, Either<`[`C`](../right.html#C)`, `[`B`](../right.html#B)`>>`<br>Create a sum of a type [C](../right.html#C) and the [PPrism](./index.html) |

### Companion Object Extension Functions

| [invoke](../invoke.html) | `operator fun <S, A> PPrism.Companion.invoke(getOption: (`[`S`](../invoke.html#S)`) -> Option<`[`A`](../invoke.html#A)`>, reverseGet: (`[`A`](../invoke.html#A)`) -> `[`S`](../invoke.html#S)`): `[`Prism`](../-prism.html)`<`[`S`](../invoke.html#S)`, `[`A`](../invoke.html#A)`>`<br>Invoke operator overload to create a [PPrism](./index.html) of type `S` with a focus `A` where `A` is a subtype of `S` Can also be used to construct [Prism](../-prism.html) |

