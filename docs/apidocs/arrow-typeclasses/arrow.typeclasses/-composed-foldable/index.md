---
title: ComposedFoldable - arrow-typeclasses
---

[arrow-typeclasses](../../index.html) / [arrow.typeclasses](../index.html) / [ComposedFoldable](./index.html)

# ComposedFoldable

`interface ComposedFoldable<F, G> : `[`Foldable`](../-foldable/index.html)`<`[`Nested`](../-nested.html)`<`[`F`](index.html#F)`, `[`G`](index.html#G)`>>`

### Functions

| [FF](-f-f.html) | `abstract fun FF(): `[`Foldable`](../-foldable/index.html)`<`[`F`](index.html#F)`>` |
| [GF](-g-f.html) | `abstract fun GF(): `[`Foldable`](../-foldable/index.html)`<`[`G`](index.html#G)`>` |
| [foldLC](fold-l-c.html) | `open fun <A, B> foldLC(fa: `[`UnnestedType`](../-unnested-type.html)`<`[`F`](index.html#F)`, `[`G`](index.html#G)`, `[`A`](fold-l-c.html#A)`>, b: `[`B`](fold-l-c.html#B)`, f: (`[`B`](fold-l-c.html#B)`, `[`A`](fold-l-c.html#A)`) -> `[`B`](fold-l-c.html#B)`): `[`B`](fold-l-c.html#B) |
| [foldLeft](fold-left.html) | `open fun <A, B> `[`NestedType`](../-nested-type.html)`<`[`F`](index.html#F)`, `[`G`](index.html#G)`, `[`A`](fold-left.html#A)`>.foldLeft(b: `[`B`](fold-left.html#B)`, f: (`[`B`](fold-left.html#B)`, `[`A`](fold-left.html#A)`) -> `[`B`](fold-left.html#B)`): `[`B`](fold-left.html#B)<br>Left associative fold on F using the provided function. |
| [foldRC](fold-r-c.html) | `open fun <A, B> `[`UnnestedType`](../-unnested-type.html)`<`[`F`](index.html#F)`, `[`G`](index.html#G)`, `[`A`](fold-r-c.html#A)`>.foldRC(lb: Eval<`[`B`](fold-r-c.html#B)`>, f: (`[`A`](fold-r-c.html#A)`, Eval<`[`B`](fold-r-c.html#B)`>) -> Eval<`[`B`](fold-r-c.html#B)`>): Eval<`[`B`](fold-r-c.html#B)`>` |
| [foldRight](fold-right.html) | `open fun <A, B> `[`NestedType`](../-nested-type.html)`<`[`F`](index.html#F)`, `[`G`](index.html#G)`, `[`A`](fold-right.html#A)`>.foldRight(lb: Eval<`[`B`](fold-right.html#B)`>, f: (`[`A`](fold-right.html#A)`, Eval<`[`B`](fold-right.html#B)`>) -> Eval<`[`B`](fold-right.html#B)`>): Eval<`[`B`](fold-right.html#B)`>`<br>Right associative lazy fold on F using the provided function. |

### Inherited Functions

| [combineAll](../-foldable/combine-all.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/combine-all.html#A)`>.combineAll(MN: `[`Monoid`](../-monoid/index.html)`<`[`A`](../-foldable/combine-all.html#A)`>): `[`A`](../-foldable/combine-all.html#A)<br>Alias for fold. |
| [exists](../-foldable/exists.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/exists.html#A)`>.exists(p: (`[`A`](../-foldable/exists.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check whether at least one element satisfies the predicate. |
| [find](../-foldable/find.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/find.html#A)`>.find(f: (`[`A`](../-foldable/find.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): Option<`[`A`](../-foldable/find.html#A)`>`<br>Find the first element matching the predicate, if one exists. |
| [fold](../-foldable/fold.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/fold.html#A)`>.fold(MN: `[`Monoid`](../-monoid/index.html)`<`[`A`](../-foldable/fold.html#A)`>): `[`A`](../-foldable/fold.html#A)<br>Fold implemented using the given Monoid instance. |
| [foldM](../-foldable/fold-m.html) | `open fun <G, A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/fold-m.html#A)`>.foldM(M: `[`Monad`](../-monad/index.html)`<`[`G`](../-foldable/fold-m.html#G)`>, z: `[`B`](../-foldable/fold-m.html#B)`, f: (`[`B`](../-foldable/fold-m.html#B)`, `[`A`](../-foldable/fold-m.html#A)`) -> Kind<`[`G`](../-foldable/fold-m.html#G)`, `[`B`](../-foldable/fold-m.html#B)`>): Kind<`[`G`](../-foldable/fold-m.html#G)`, `[`B`](../-foldable/fold-m.html#B)`>`<br>Left associative monadic folding on F. |
| [foldMap](../-foldable/fold-map.html) | `open fun <A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/fold-map.html#A)`>.foldMap(MN: `[`Monoid`](../-monoid/index.html)`<`[`B`](../-foldable/fold-map.html#B)`>, f: (`[`A`](../-foldable/fold-map.html#A)`) -> `[`B`](../-foldable/fold-map.html#B)`): `[`B`](../-foldable/fold-map.html#B)<br>Fold implemented by mapping A values into B and then combining them using the given Monoid instance. |
| [foldMapM](../-foldable/fold-map-m.html) | `open fun <G, A, B, MA : `[`Monad`](../-monad/index.html)`<`[`G`](../-foldable/fold-map-m.html#G)`>, MO : `[`Monoid`](../-monoid/index.html)`<`[`B`](../-foldable/fold-map-m.html#B)`>> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/fold-map-m.html#A)`>.foldMapM(ma: `[`MA`](../-foldable/fold-map-m.html#MA)`, mo: `[`MO`](../-foldable/fold-map-m.html#MO)`, f: (`[`A`](../-foldable/fold-map-m.html#A)`) -> Kind<`[`G`](../-foldable/fold-map-m.html#G)`, `[`B`](../-foldable/fold-map-m.html#B)`>): Kind<`[`G`](../-foldable/fold-map-m.html#G)`, `[`B`](../-foldable/fold-map-m.html#B)`>`<br>Monadic folding on F by mapping A values to G, combining the B values using the given Monoid instance. |
| [forAll](../-foldable/for-all.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/for-all.html#A)`>.forAll(p: (`[`A`](../-foldable/for-all.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check whether all elements satisfy the predicate. |
| [get](../-foldable/get.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/get.html#A)`>.get(M: `[`Monad`](../-monad/index.html)`<Kind<ForEither, `[`A`](../-foldable/get.html#A)`>>, idx: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): Option<`[`A`](../-foldable/get.html#A)`>`<br>Get the element at the index of the Foldable. |
| [isEmpty](../-foldable/is-empty.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/is-empty.html#A)`>.isEmpty(): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Returns true if there are no elements. Otherwise false. |
| [nonEmpty](../-foldable/non-empty.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/non-empty.html#A)`>.nonEmpty(): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html) |
| [reduceLeftOption](../-foldable/reduce-left-option.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/reduce-left-option.html#A)`>.reduceLeftOption(f: (`[`A`](../-foldable/reduce-left-option.html#A)`, `[`A`](../-foldable/reduce-left-option.html#A)`) -> `[`A`](../-foldable/reduce-left-option.html#A)`): Option<`[`A`](../-foldable/reduce-left-option.html#A)`>`<br>Reduce the elements of this structure down to a single value by applying the provided aggregation function in a left-associative manner. |
| [reduceLeftToOption](../-foldable/reduce-left-to-option.html) | `open fun <A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/reduce-left-to-option.html#A)`>.reduceLeftToOption(f: (`[`A`](../-foldable/reduce-left-to-option.html#A)`) -> `[`B`](../-foldable/reduce-left-to-option.html#B)`, g: (`[`B`](../-foldable/reduce-left-to-option.html#B)`, `[`A`](../-foldable/reduce-left-to-option.html#A)`) -> `[`B`](../-foldable/reduce-left-to-option.html#B)`): Option<`[`B`](../-foldable/reduce-left-to-option.html#B)`>` |
| [reduceRightOption](../-foldable/reduce-right-option.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/reduce-right-option.html#A)`>.reduceRightOption(f: (`[`A`](../-foldable/reduce-right-option.html#A)`, Eval<`[`A`](../-foldable/reduce-right-option.html#A)`>) -> Eval<`[`A`](../-foldable/reduce-right-option.html#A)`>): Eval<Option<`[`A`](../-foldable/reduce-right-option.html#A)`>>`<br>Reduce the elements of this structure down to a single value by applying the provided aggregation function in a right-associative manner. |
| [reduceRightToOption](../-foldable/reduce-right-to-option.html) | `open fun <A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/reduce-right-to-option.html#A)`>.reduceRightToOption(f: (`[`A`](../-foldable/reduce-right-to-option.html#A)`) -> `[`B`](../-foldable/reduce-right-to-option.html#B)`, g: (`[`A`](../-foldable/reduce-right-to-option.html#A)`, Eval<`[`B`](../-foldable/reduce-right-to-option.html#B)`>) -> Eval<`[`B`](../-foldable/reduce-right-to-option.html#B)`>): Eval<Option<`[`B`](../-foldable/reduce-right-to-option.html#B)`>>` |
| [sequence_](../-foldable/sequence_.html) | `open fun <G, A> Kind<`[`F`](../-foldable/index.html#F)`, Kind<`[`G`](../-foldable/sequence_.html#G)`, `[`A`](../-foldable/sequence_.html#A)`>>.sequence_(ag: `[`Applicative`](../-applicative/index.html)`<`[`G`](../-foldable/sequence_.html#G)`>): Kind<`[`G`](../-foldable/sequence_.html#G)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Sequence F&lt;G&gt; using Applicative. |
| [size](../-foldable/size.html) | `open fun <A> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/size.html#A)`>.size(MN: `[`Monoid`](../-monoid/index.html)`<`[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`>): `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>The size of this Foldable. |
| [traverse_](../-foldable/traverse_.html) | `open fun <G, A, B> Kind<`[`F`](../-foldable/index.html#F)`, `[`A`](../-foldable/traverse_.html#A)`>.traverse_(GA: `[`Applicative`](../-applicative/index.html)`<`[`G`](../-foldable/traverse_.html#G)`>, f: (`[`A`](../-foldable/traverse_.html#A)`) -> Kind<`[`G`](../-foldable/traverse_.html#G)`, `[`B`](../-foldable/traverse_.html#B)`>): Kind<`[`G`](../-foldable/traverse_.html#G)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Traverse F using Applicative. |

### Companion Object Functions

| [invoke](invoke.html) | `operator fun <F, G> invoke(FF: `[`Foldable`](../-foldable/index.html)`<`[`F`](invoke.html#F)`>, GF: `[`Foldable`](../-foldable/index.html)`<`[`G`](invoke.html#G)`>): `[`ComposedFoldable`](./index.html)`<`[`F`](invoke.html#F)`, `[`G`](invoke.html#G)`>` |

### Extension Functions

| [compose](../compose.html) | `fun <F, G> `[`Foldable`](../-foldable/index.html)`<`[`F`](../compose.html#F)`>.compose(GT: `[`Foldable`](../-foldable/index.html)`<`[`G`](../compose.html#G)`>): `[`ComposedFoldable`](./index.html)`<`[`F`](../compose.html#F)`, `[`G`](../compose.html#G)`>` |

### Inheritors

| [ComposedTraverse](../-composed-traverse/index.html) | `interface ComposedTraverse<F, G> : `[`Traverse`](../-traverse/index.html)`<`[`Nested`](../-nested.html)`<`[`F`](../-composed-traverse/index.html#F)`, `[`G`](../-composed-traverse/index.html#G)`>>, `[`ComposedFoldable`](./index.html)`<`[`F`](../-composed-traverse/index.html#F)`, `[`G`](../-composed-traverse/index.html#G)`>` |

