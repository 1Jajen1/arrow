---
title: PIso - arrow-optics
---

[arrow-optics](../../index.html) / [arrow.optics](../index.html) / [PIso](./index.html)

# PIso

`@higherkind interface PIso<S, T, A, B> : `[`PIsoOf`](../-p-iso-of.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>`

An [Iso](../-iso.html) is a loss less invertible optic that defines an isomorphism between a type [S](index.html#S) and [A](index.html#A)
i.e. a data class and its properties represented by TupleN

A (polymorphic) [PIso](./index.html) is useful when setting or modifying a value for a constructed type
i.e. PIso&lt;Option, Option, Int?, String?&gt;

An [PIso](./index.html) is also a valid [PLens](../-p-lens/index.html), [PPrism](../-p-prism/index.html)

### Parameters

`S` - the source of a [PIso](./index.html)

`T` - the modified source of a [PIso](./index.html)

`A` - the focus of a [PIso](./index.html)

`B` - the modified target of a [PIso](./index.html)

### Functions

| [asFold](as-fold.html) | `open fun asFold(): `[`Fold`](../-fold/index.html)`<`[`S`](index.html#S)`, `[`A`](index.html#A)`>`<br>View a [PIso](./index.html) as a [Fold](../-fold/index.html) |
| [asGetter](as-getter.html) | `open fun asGetter(): `[`Getter`](../-getter/index.html)`<`[`S`](index.html#S)`, `[`A`](index.html#A)`>`<br>View a [PIso](./index.html) as a [Getter](../-getter/index.html) |
| [asLens](as-lens.html) | `open fun asLens(): `[`PLens`](../-p-lens/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>`<br>View a [PIso](./index.html) as a [PLens](../-p-lens/index.html) |
| [asOptional](as-optional.html) | `open fun asOptional(): `[`POptional`](../-p-optional/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>`<br>View a [PIso](./index.html) as a [POptional](../-p-optional/index.html) |
| [asPrism](as-prism.html) | `open fun asPrism(): `[`PPrism`](../-p-prism/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>`<br>View a [PIso](./index.html) as a [PPrism](../-p-prism/index.html) |
| [asSetter](as-setter.html) | `open fun asSetter(): `[`PSetter`](../-p-setter/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>`<br>View a [PIso](./index.html) as a [PSetter](../-p-setter/index.html) |
| [asTraversal](as-traversal.html) | `open fun asTraversal(): `[`PTraversal`](../-p-traversal/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>`<br>View a [PIso](./index.html) as a [PTraversal](../-p-traversal/index.html) |
| [compose](compose.html) | `open infix fun <C, D> compose(other: `[`PIso`](./index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PIso`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PIso](./index.html) with a [PIso](./index.html)`open infix fun <C, D> compose(other: `[`PLens`](../-p-lens/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PLens`](../-p-lens/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PIso](./index.html) with a [PLens](../-p-lens/index.html)`open infix fun <C, D> compose(other: `[`PPrism`](../-p-prism/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PPrism`](../-p-prism/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PIso](./index.html) with a [PPrism](../-p-prism/index.html)`open infix fun <C> compose(other: `[`Getter`](../-getter/index.html)`<`[`A`](index.html#A)`, `[`C`](compose.html#C)`>): `[`Getter`](../-getter/index.html)`<`[`S`](index.html#S)`, `[`C`](compose.html#C)`>`<br>Compose a [PIso](./index.html) with a [Getter](../-getter/index.html)`open infix fun <C, D> compose(other: `[`PSetter`](../-p-setter/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PSetter`](../-p-setter/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PIso](./index.html) with a [PSetter](../-p-setter/index.html)`open infix fun <C, D> compose(other: `[`POptional`](../-p-optional/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`POptional`](../-p-optional/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PIso](./index.html) with a [POptional](../-p-optional/index.html)`open infix fun <C> compose(other: `[`Fold`](../-fold/index.html)`<`[`A`](index.html#A)`, `[`C`](compose.html#C)`>): `[`Fold`](../-fold/index.html)`<`[`S`](index.html#S)`, `[`C`](compose.html#C)`>`<br>Compose a [PIso](./index.html) with a [Fold](../-fold/index.html)`open infix fun <C, D> compose(other: `[`PTraversal`](../-p-traversal/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PTraversal`](../-p-traversal/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PIso](./index.html) with a [PTraversal](../-p-traversal/index.html) |
| [exist](exist.html) | `open fun exist(s: `[`S`](index.html#S)`, p: (`[`A`](index.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if the focus satisfies the predicate |
| [find](find.html) | `open fun find(s: `[`S`](index.html#S)`, p: (`[`A`](index.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): Option<`[`A`](index.html#A)`>`<br>Find if the focus satisfies the predicate |
| [first](first.html) | `open fun <C> first(): `[`PIso`](./index.html)`<Tuple2<`[`S`](index.html#S)`, `[`C`](first.html#C)`>, Tuple2<`[`T`](index.html#T)`, `[`C`](first.html#C)`>, Tuple2<`[`A`](index.html#A)`, `[`C`](first.html#C)`>, Tuple2<`[`B`](index.html#B)`, `[`C`](first.html#C)`>>`<br>Create a pair of the [PIso](./index.html) and a type [C](first.html#C) |
| [get](get.html) | `abstract fun get(s: `[`S`](index.html#S)`): `[`A`](index.html#A)<br>Get the focus of a [PIso](./index.html) |
| [left](left.html) | `open fun <C> left(): `[`PIso`](./index.html)`<Either<`[`S`](index.html#S)`, `[`C`](left.html#C)`>, Either<`[`T`](index.html#T)`, `[`C`](left.html#C)`>, Either<`[`A`](index.html#A)`, `[`C`](left.html#C)`>, Either<`[`B`](index.html#B)`, `[`C`](left.html#C)`>>`<br>Create a sum of the [PIso](./index.html) and a type [C](left.html#C) |
| [lift](lift.html) | `open fun lift(f: (`[`A`](index.html#A)`) -> `[`B`](index.html#B)`): (`[`S`](index.html#S)`) -> `[`T`](index.html#T)<br>Modify polymorphically the focus of a [PIso](./index.html) with a function |
| [liftF](lift-f.html) | `open fun <F> liftF(FF: Functor<`[`F`](lift-f.html#F)`>, f: (`[`A`](index.html#A)`) -> Kind<`[`F`](lift-f.html#F)`, `[`B`](index.html#B)`>): (`[`S`](index.html#S)`) -> Kind<`[`F`](lift-f.html#F)`, `[`T`](index.html#T)`>`<br>`open fun <F> liftF(FF: Functor<`[`F`](lift-f.html#F)`>, dummy: `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)` = Unit, f: (`[`A`](index.html#A)`) -> Kind<`[`F`](lift-f.html#F)`, `[`B`](index.html#B)`>): (`[`S`](index.html#S)`) -> Kind<`[`F`](lift-f.html#F)`, `[`T`](index.html#T)`>`<br>Lift a function [f](lift-f.html#arrow.optics.PIso$liftF(arrow.typeclasses.Functor((arrow.optics.PIso.liftF.F)), kotlin.Function1((arrow.optics.PIso.A, arrow.Kind((arrow.optics.PIso.liftF.F, arrow.optics.PIso.B)))))/f) with a functor: `(A) -> Kind<F, B> to the context of `S`: `(S) -&gt; Kind&lt;F, T&gt;` |
| [mapping](mapping.html) | `open fun <F> mapping(FF: Functor<`[`F`](mapping.html#F)`>): `[`PIso`](./index.html)`<Kind<`[`F`](mapping.html#F)`, `[`S`](index.html#S)`>, Kind<`[`F`](mapping.html#F)`, `[`T`](index.html#T)`>, Kind<`[`F`](mapping.html#F)`, `[`A`](index.html#A)`>, Kind<`[`F`](mapping.html#F)`, `[`B`](index.html#B)`>>`<br>Lift a [PIso](./index.html) to a Functor level |
| [modify](modify.html) | `open fun modify(s: `[`S`](index.html#S)`, f: (`[`A`](index.html#A)`) -> `[`B`](index.html#B)`): `[`T`](index.html#T)<br>Modify polymorphically the focus of a [PIso](./index.html) with a function |
| [modifyF](modify-f.html) | `open fun <F> modifyF(FF: Functor<`[`F`](modify-f.html#F)`>, s: `[`S`](index.html#S)`, f: (`[`A`](index.html#A)`) -> Kind<`[`F`](modify-f.html#F)`, `[`B`](index.html#B)`>): Kind<`[`F`](modify-f.html#F)`, `[`T`](index.html#T)`>`<br>Modify polymorphically the target of a [PIso](./index.html) with a Functor function |
| [plus](plus.html) | `open operator fun <C, D> plus(other: `[`PIso`](./index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PIso`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>Plus operator overload to compose lenses`open operator fun <C, D> plus(other: `[`PLens`](../-p-lens/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PLens`](../-p-lens/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C, D> plus(other: `[`PPrism`](../-p-prism/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PPrism`](../-p-prism/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C> plus(other: `[`Getter`](../-getter/index.html)`<`[`A`](index.html#A)`, `[`C`](plus.html#C)`>): `[`Getter`](../-getter/index.html)`<`[`S`](index.html#S)`, `[`C`](plus.html#C)`>`<br>`open operator fun <C, D> plus(other: `[`PSetter`](../-p-setter/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PSetter`](../-p-setter/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C, D> plus(other: `[`POptional`](../-p-optional/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`POptional`](../-p-optional/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C> plus(other: `[`Fold`](../-fold/index.html)`<`[`A`](index.html#A)`, `[`C`](plus.html#C)`>): `[`Fold`](../-fold/index.html)`<`[`S`](index.html#S)`, `[`C`](plus.html#C)`>`<br>`open operator fun <C, D> plus(other: `[`PTraversal`](../-p-traversal/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PTraversal`](../-p-traversal/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>` |
| [reverse](reverse.html) | `open fun reverse(): `[`PIso`](./index.html)`<`[`B`](index.html#B)`, `[`A`](index.html#A)`, `[`T`](index.html#T)`, `[`S`](index.html#S)`>`<br>Reverse a [PIso](./index.html): the source becomes the target and the target becomes the source |
| [reverseGet](reverse-get.html) | `abstract fun reverseGet(b: `[`B`](index.html#B)`): `[`T`](index.html#T)<br>Get the modified focus of a [PIso](./index.html) |
| [right](right.html) | `open fun <C> right(): `[`PIso`](./index.html)`<Either<`[`C`](right.html#C)`, `[`S`](index.html#S)`>, Either<`[`C`](right.html#C)`, `[`T`](index.html#T)`>, Either<`[`C`](right.html#C)`, `[`A`](index.html#A)`>, Either<`[`C`](right.html#C)`, `[`B`](index.html#B)`>>`<br>Create a sum of a type [C](right.html#C) and the [PIso](./index.html) |
| [second](second.html) | `open fun <C> second(): `[`PIso`](./index.html)`<Tuple2<`[`C`](second.html#C)`, `[`S`](index.html#S)`>, Tuple2<`[`C`](second.html#C)`, `[`T`](index.html#T)`>, Tuple2<`[`C`](second.html#C)`, `[`A`](index.html#A)`>, Tuple2<`[`C`](second.html#C)`, `[`B`](index.html#B)`>>`<br>Create a pair of a type [C](second.html#C) and the [PIso](./index.html) |
| [set](set.html) | `open fun set(b: `[`B`](index.html#B)`): `[`T`](index.html#T)<br>Set polymorphically the focus of a [PIso](./index.html) with a value |
| [split](split.html) | `open infix fun <S1, T1, A1, B1> split(other: `[`PIso`](./index.html)`<`[`S1`](split.html#S1)`, `[`T1`](split.html#T1)`, `[`A1`](split.html#A1)`, `[`B1`](split.html#B1)`>): `[`PIso`](./index.html)`<Tuple2<`[`S`](index.html#S)`, `[`S1`](split.html#S1)`>, Tuple2<`[`T`](index.html#T)`, `[`T1`](split.html#T1)`>, Tuple2<`[`A`](index.html#A)`, `[`A1`](split.html#A1)`>, Tuple2<`[`B`](index.html#B)`, `[`B1`](split.html#B1)`>>`<br>Pair two disjoint [PIso](./index.html) |

### Companion Object Functions

| [id](id.html) | `fun <S> id(): `[`Iso`](../-iso.html)`<`[`S`](id.html#S)`, `[`S`](id.html#S)`>`<br>create an [PIso](./index.html) between any type and itself. Id is the zero element of optics composition, for any optic o of type O (e.g. PLens, Prism, POptional, ...): o compose Iso.id == o |
| [invoke](invoke.html) | `operator fun <S, T, A, B> invoke(get: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, reverseGet: (`[`B`](invoke.html#B)`) -> `[`T`](invoke.html#T)`): `[`PIso`](./index.html)`<`[`S`](invoke.html#S)`, `[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`, `[`B`](invoke.html#B)`>`<br>Invoke operator overload to create a [PIso](./index.html) of type `S` with target `A`. Can also be used to construct [Iso](../-iso.html) |

### Extension Properties

| [every](../../arrow.optics.typeclasses/-each/every.html) | `open val <T> `[`Iso`](../-iso.html)`<`[`T`](../../arrow.optics.typeclasses/-each/every.html#T)`, `[`S`](../../arrow.optics.typeclasses/-each/index.html#S)`>.every: `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.typeclasses/-each/every.html#T)`, `[`A`](../../arrow.optics.typeclasses/-each/index.html#A)`>`<br>DSL to compose [Each](../../arrow.optics.typeclasses/-each/index.html) with a [Iso](../-iso.html) for a structure [S](../../arrow.optics.typeclasses/-each/index.html#S) to see all its foci [A](../../arrow.optics.typeclasses/-each/index.html#A) |
| [some](../../arrow.optics.dsl/some.html) | `val <T, S> `[`Iso`](../-iso.html)`<`[`T`](../../arrow.optics.dsl/some.html#T)`, Option<`[`S`](../../arrow.optics.dsl/some.html#S)`>>.some: `[`Prism`](../-prism.html)`<`[`T`](../../arrow.optics.dsl/some.html#T)`, `[`S`](../../arrow.optics.dsl/some.html#S)`>`<br>DSL to compose a [Prism](../-prism.html) with focus [arrow.core.Some](#) with a [Iso](../-iso.html) with a focus of [Option](#)&lt;[S](../../arrow.optics.dsl/some.html#S)&gt; |

### Extension Functions

| [at](../../arrow.optics.dsl/at.html) | `fun <T, S, I, A> `[`Iso`](../-iso.html)`<`[`T`](../../arrow.optics.dsl/at.html#T)`, `[`S`](../../arrow.optics.dsl/at.html#S)`>.at(AT: `[`At`](../../arrow.optics.typeclasses/-at/index.html)`<`[`S`](../../arrow.optics.dsl/at.html#S)`, `[`I`](../../arrow.optics.dsl/at.html#I)`, `[`A`](../../arrow.optics.dsl/at.html#A)`>, i: `[`I`](../../arrow.optics.dsl/at.html#I)`): `[`Lens`](../-lens.html)`<`[`T`](../../arrow.optics.dsl/at.html#T)`, `[`A`](../../arrow.optics.dsl/at.html#A)`>`<br>DSL to compose [At](../../arrow.optics.typeclasses/-at/index.html) with an [Iso](../-iso.html) for a structure [S](../../arrow.optics.dsl/at.html#S) to focus in on [A](../../arrow.optics.dsl/at.html#A) at given index [I](../../arrow.optics.dsl/at.html#I). |
| [every](../../arrow.optics.dsl/every.html) | `fun <T, S, A> `[`Iso`](../-iso.html)`<`[`T`](../../arrow.optics.dsl/every.html#T)`, `[`S`](../../arrow.optics.dsl/every.html#S)`>.every(EA: `[`Each`](../../arrow.optics.typeclasses/-each/index.html)`<`[`S`](../../arrow.optics.dsl/every.html#S)`, `[`A`](../../arrow.optics.dsl/every.html#A)`>): `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.dsl/every.html#T)`, `[`A`](../../arrow.optics.dsl/every.html#A)`>`<br>DSL to compose [Each](../../arrow.optics.typeclasses/-each/index.html) with an [Iso](../-iso.html) for a structure [S](../../arrow.optics.dsl/every.html#S) to see all its foci [A](../../arrow.optics.dsl/every.html#A) |
| [index](../../arrow.optics.dsl/--index--.html) | `fun <T, S, I, A> `[`Iso`](../-iso.html)`<`[`T`](../../arrow.optics.dsl/--index--.html#T)`, `[`S`](../../arrow.optics.dsl/--index--.html#S)`>.index(ID: `[`Index`](../../arrow.optics.typeclasses/-index/index.html)`<`[`S`](../../arrow.optics.dsl/--index--.html#S)`, `[`I`](../../arrow.optics.dsl/--index--.html#I)`, `[`A`](../../arrow.optics.dsl/--index--.html#A)`>, i: `[`I`](../../arrow.optics.dsl/--index--.html#I)`): `[`Optional`](../-optional.html)`<`[`T`](../../arrow.optics.dsl/--index--.html#T)`, `[`A`](../../arrow.optics.dsl/--index--.html#A)`>`<br>DSL to compose [Index](../../arrow.optics.typeclasses/-index/index.html) with an [Iso](../-iso.html) for a structure [S](../../arrow.optics.dsl/--index--.html#S) to focus in on [A](../../arrow.optics.dsl/--index--.html#A) at given index [I](../../arrow.optics.dsl/--index--.html#I) |

