---
title: arrow.optics - arrow-optics
---

[arrow-optics](../index.html) / [arrow.optics](./index.html)

## Package arrow.optics

### Types

| [Fold](-fold/index.html) | `interface Fold<S, A> : `[`FoldOf`](-fold-of.html)`<`[`S`](-fold/index.html#S)`, `[`A`](-fold/index.html#A)`>`<br>A [Fold](-fold/index.html) is an optic that allows to focus into structure and get multiple results. |
| [ForFold](-for-fold.html) | `class ForFold` |
| [ForGetter](-for-getter.html) | `class ForGetter` |
| [ForPIso](-for-p-iso.html) | `class ForPIso` |
| [ForPLens](-for-p-lens.html) | `class ForPLens` |
| [ForPOptional](-for-p-optional.html) | `class ForPOptional` |
| [ForPPrism](-for-p-prism.html) | `class ForPPrism` |
| [ForPSetter](-for-p-setter.html) | `class ForPSetter` |
| [ForPTraversal](-for-p-traversal.html) | `class ForPTraversal` |
| [Getter](-getter/index.html) | `interface Getter<S, A> : `[`GetterOf`](-getter-of.html)`<`[`S`](-getter/index.html#S)`, `[`A`](-getter/index.html#A)`>`<br>A [Getter](-getter/index.html) is an optic that allows to see into a structure and getting a focus. |
| [PIso](-p-iso/index.html) | `interface PIso<S, T, A, B> : `[`PIsoOf`](-p-iso-of.html)`<`[`S`](-p-iso/index.html#S)`, `[`T`](-p-iso/index.html#T)`, `[`A`](-p-iso/index.html#A)`, `[`B`](-p-iso/index.html#B)`>`<br>An [Iso](-iso.html) is a loss less invertible optic that defines an isomorphism between a type [S](-p-iso/index.html#S) and [A](-p-iso/index.html#A) i.e. a data class and its properties represented by TupleN |
| [PLens](-p-lens/index.html) | `interface PLens<S, T, A, B> : `[`PLensOf`](-p-lens-of.html)`<`[`S`](-p-lens/index.html#S)`, `[`T`](-p-lens/index.html#T)`, `[`A`](-p-lens/index.html#A)`, `[`B`](-p-lens/index.html#B)`>`<br>A [Lens](-lens.html) (or Functional Reference) is an optic that can focus into a structure for getting, setting or modifying the focus (target). |
| [POptional](-p-optional/index.html) | `interface POptional<S, T, A, B> : `[`POptionalOf`](-p-optional-of.html)`<`[`S`](-p-optional/index.html#S)`, `[`T`](-p-optional/index.html#T)`, `[`A`](-p-optional/index.html#A)`, `[`B`](-p-optional/index.html#B)`>`<br>An [Optional](-optional.html) is an optic that allows to see into a structure and getting, setting or modifying an optional focus. |
| [PPrism](-p-prism/index.html) | `interface PPrism<S, T, A, B> : `[`PPrismOf`](-p-prism-of.html)`<`[`S`](-p-prism/index.html#S)`, `[`T`](-p-prism/index.html#T)`, `[`A`](-p-prism/index.html#A)`, `[`B`](-p-prism/index.html#B)`>`<br>A [Prism](-prism.html) is a loss less invertible optic that can look into a structure and optionally find its focus. Mostly used for finding a focus that is only present under certain conditions i.e. list head Prism&lt;List, Int&gt; |
| [PSetter](-p-setter/index.html) | `interface PSetter<S, T, A, B> : `[`PSetterOf`](-p-setter-of.html)`<`[`S`](-p-setter/index.html#S)`, `[`T`](-p-setter/index.html#T)`, `[`A`](-p-setter/index.html#A)`, `[`B`](-p-setter/index.html#B)`>`<br>A [Setter](-setter.html) is an optic that allows to see into a structure and set or modify its focus. |
| [PTraversal](-p-traversal/index.html) | `interface PTraversal<S, T, A, B> : `[`PTraversalOf`](-p-traversal-of.html)`<`[`S`](-p-traversal/index.html#S)`, `[`T`](-p-traversal/index.html#T)`, `[`A`](-p-traversal/index.html#A)`, `[`B`](-p-traversal/index.html#B)`>`<br>A [Traversal](-traversal.html) is an optic that allows to see into a structure with 0 to N foci. |

### Type Aliases

| [FoldKindedJ](-fold-kinded-j.html) | `typealias FoldKindedJ<S, A> = HkJ2<`[`ForFold`](-for-fold.html)`, `[`S`](-fold-kinded-j.html#S)`, `[`A`](-fold-kinded-j.html#A)`>` |
| [FoldOf](-fold-of.html) | `typealias FoldOf<S, A> = Kind2<`[`ForFold`](-for-fold.html)`, `[`S`](-fold-of.html#S)`, `[`A`](-fold-of.html#A)`>` |
| [FoldPartialOf](-fold-partial-of.html) | `typealias FoldPartialOf<S> = Kind<`[`ForFold`](-for-fold.html)`, `[`S`](-fold-partial-of.html#S)`>` |
| [ForIso](-for-iso.html) | `typealias ForIso = `[`ForPIso`](-for-p-iso.html) |
| [ForLens](-for-lens.html) | `typealias ForLens = `[`ForPLens`](-for-p-lens.html) |
| [ForOptional](-for-optional.html) | `typealias ForOptional = `[`ForPOptional`](-for-p-optional.html) |
| [ForPrism](-for-prism.html) | `typealias ForPrism = `[`ForPPrism`](-for-p-prism.html) |
| [ForSetter](-for-setter.html) | `typealias ForSetter = `[`ForPSetter`](-for-p-setter.html) |
| [ForTraversal](-for-traversal.html) | `typealias ForTraversal = `[`ForPTraversal`](-for-p-traversal.html) |
| [GetterKindedJ](-getter-kinded-j.html) | `typealias GetterKindedJ<S, A> = HkJ2<`[`ForGetter`](-for-getter.html)`, `[`S`](-getter-kinded-j.html#S)`, `[`A`](-getter-kinded-j.html#A)`>` |
| [GetterOf](-getter-of.html) | `typealias GetterOf<S, A> = Kind2<`[`ForGetter`](-for-getter.html)`, `[`S`](-getter-of.html#S)`, `[`A`](-getter-of.html#A)`>` |
| [GetterPartialOf](-getter-partial-of.html) | `typealias GetterPartialOf<S> = Kind<`[`ForGetter`](-for-getter.html)`, `[`S`](-getter-partial-of.html#S)`>` |
| [Iso](-iso.html) | `typealias Iso<S, A> = `[`PIso`](-p-iso/index.html)`<`[`S`](-iso.html#S)`, `[`S`](-iso.html#S)`, `[`A`](-iso.html#A)`, `[`A`](-iso.html#A)`>`<br>[Iso](-iso.html) is a type alias for [PIso](-p-iso/index.html) which fixes the type arguments and restricts the [PIso](-p-iso/index.html) to monomorphic updates. |
| [IsoKindedJ](-iso-kinded-j.html) | `typealias IsoKindedJ<S, A> = `[`PIsoKindedJ`](-p-iso-kinded-j.html)`<`[`S`](-iso-kinded-j.html#S)`, `[`S`](-iso-kinded-j.html#S)`, `[`A`](-iso-kinded-j.html#A)`, `[`A`](-iso-kinded-j.html#A)`>` |
| [IsoOf](-iso-of.html) | `typealias IsoOf<S, A> = `[`PIsoOf`](-p-iso-of.html)`<`[`S`](-iso-of.html#S)`, `[`S`](-iso-of.html#S)`, `[`A`](-iso-of.html#A)`, `[`A`](-iso-of.html#A)`>` |
| [IsoPartialOf](-iso-partial-of.html) | `typealias IsoPartialOf<S> = Kind<`[`ForIso`](-for-iso.html)`, `[`S`](-iso-partial-of.html#S)`>` |
| [Lens](-lens.html) | `typealias Lens<S, A> = `[`PLens`](-p-lens/index.html)`<`[`S`](-lens.html#S)`, `[`S`](-lens.html#S)`, `[`A`](-lens.html#A)`, `[`A`](-lens.html#A)`>`<br>[Lens](-lens.html) is a type alias for [PLens](-p-lens/index.html) which fixes the type arguments and restricts the [PLens](-p-lens/index.html) to monomorphic updates. |
| [LensKindedJ](-lens-kinded-j.html) | `typealias LensKindedJ<S, A> = `[`PLensKindedJ`](-p-lens-kinded-j.html)`<`[`S`](-lens-kinded-j.html#S)`, `[`S`](-lens-kinded-j.html#S)`, `[`A`](-lens-kinded-j.html#A)`, `[`A`](-lens-kinded-j.html#A)`>` |
| [LensOf](-lens-of.html) | `typealias LensOf<S, A> = `[`PLensOf`](-p-lens-of.html)`<`[`S`](-lens-of.html#S)`, `[`S`](-lens-of.html#S)`, `[`A`](-lens-of.html#A)`, `[`A`](-lens-of.html#A)`>` |
| [LensPartialOf](-lens-partial-of.html) | `typealias LensPartialOf<S> = Kind<`[`ForLens`](-for-lens.html)`, `[`S`](-lens-partial-of.html#S)`>` |
| [Optional](-optional.html) | `typealias Optional<S, A> = `[`POptional`](-p-optional/index.html)`<`[`S`](-optional.html#S)`, `[`S`](-optional.html#S)`, `[`A`](-optional.html#A)`, `[`A`](-optional.html#A)`>`<br>[Optional](-optional.html) is a type alias for [POptional](-p-optional/index.html) which fixes the type arguments and restricts the [POptional](-p-optional/index.html) to monomorphic updates. |
| [OptionalKindedJ](-optional-kinded-j.html) | `typealias OptionalKindedJ<S, A> = `[`POptionalKindedJ`](-p-optional-kinded-j.html)`<`[`S`](-optional-kinded-j.html#S)`, `[`S`](-optional-kinded-j.html#S)`, `[`A`](-optional-kinded-j.html#A)`, `[`A`](-optional-kinded-j.html#A)`>` |
| [OptionalOf](-optional-of.html) | `typealias OptionalOf<S, A> = `[`POptionalOf`](-p-optional-of.html)`<`[`S`](-optional-of.html#S)`, `[`S`](-optional-of.html#S)`, `[`A`](-optional-of.html#A)`, `[`A`](-optional-of.html#A)`>` |
| [OptionalPartialOf](-optional-partial-of.html) | `typealias OptionalPartialOf<S> = Kind<`[`ForOptional`](-for-optional.html)`, `[`S`](-optional-partial-of.html#S)`>` |
| [PIsoKindedJ](-p-iso-kinded-j.html) | `typealias PIsoKindedJ<S, T, A, B> = HkJ4<`[`ForPIso`](-for-p-iso.html)`, `[`S`](-p-iso-kinded-j.html#S)`, `[`T`](-p-iso-kinded-j.html#T)`, `[`A`](-p-iso-kinded-j.html#A)`, `[`B`](-p-iso-kinded-j.html#B)`>` |
| [PIsoOf](-p-iso-of.html) | `typealias PIsoOf<S, T, A, B> = Kind4<`[`ForPIso`](-for-p-iso.html)`, `[`S`](-p-iso-of.html#S)`, `[`T`](-p-iso-of.html#T)`, `[`A`](-p-iso-of.html#A)`, `[`B`](-p-iso-of.html#B)`>` |
| [PIsoPartialOf](-p-iso-partial-of.html) | `typealias PIsoPartialOf<S, T, A> = Kind3<`[`ForPIso`](-for-p-iso.html)`, `[`S`](-p-iso-partial-of.html#S)`, `[`T`](-p-iso-partial-of.html#T)`, `[`A`](-p-iso-partial-of.html#A)`>` |
| [PLensKindedJ](-p-lens-kinded-j.html) | `typealias PLensKindedJ<S, T, A, B> = HkJ4<`[`ForPLens`](-for-p-lens.html)`, `[`S`](-p-lens-kinded-j.html#S)`, `[`T`](-p-lens-kinded-j.html#T)`, `[`A`](-p-lens-kinded-j.html#A)`, `[`B`](-p-lens-kinded-j.html#B)`>` |
| [PLensOf](-p-lens-of.html) | `typealias PLensOf<S, T, A, B> = Kind4<`[`ForPLens`](-for-p-lens.html)`, `[`S`](-p-lens-of.html#S)`, `[`T`](-p-lens-of.html#T)`, `[`A`](-p-lens-of.html#A)`, `[`B`](-p-lens-of.html#B)`>` |
| [PLensPartialOf](-p-lens-partial-of.html) | `typealias PLensPartialOf<S, T, A> = Kind3<`[`ForPLens`](-for-p-lens.html)`, `[`S`](-p-lens-partial-of.html#S)`, `[`T`](-p-lens-partial-of.html#T)`, `[`A`](-p-lens-partial-of.html#A)`>` |
| [POptionalKindedJ](-p-optional-kinded-j.html) | `typealias POptionalKindedJ<S, T, A, B> = HkJ4<`[`ForPOptional`](-for-p-optional.html)`, `[`S`](-p-optional-kinded-j.html#S)`, `[`T`](-p-optional-kinded-j.html#T)`, `[`A`](-p-optional-kinded-j.html#A)`, `[`B`](-p-optional-kinded-j.html#B)`>` |
| [POptionalOf](-p-optional-of.html) | `typealias POptionalOf<S, T, A, B> = Kind4<`[`ForPOptional`](-for-p-optional.html)`, `[`S`](-p-optional-of.html#S)`, `[`T`](-p-optional-of.html#T)`, `[`A`](-p-optional-of.html#A)`, `[`B`](-p-optional-of.html#B)`>` |
| [POptionalPartialOf](-p-optional-partial-of.html) | `typealias POptionalPartialOf<S, T, A> = Kind3<`[`ForPOptional`](-for-p-optional.html)`, `[`S`](-p-optional-partial-of.html#S)`, `[`T`](-p-optional-partial-of.html#T)`, `[`A`](-p-optional-partial-of.html#A)`>` |
| [PPrismKindedJ](-p-prism-kinded-j.html) | `typealias PPrismKindedJ<S, T, A, B> = HkJ4<`[`ForPPrism`](-for-p-prism.html)`, `[`S`](-p-prism-kinded-j.html#S)`, `[`T`](-p-prism-kinded-j.html#T)`, `[`A`](-p-prism-kinded-j.html#A)`, `[`B`](-p-prism-kinded-j.html#B)`>` |
| [PPrismOf](-p-prism-of.html) | `typealias PPrismOf<S, T, A, B> = Kind4<`[`ForPPrism`](-for-p-prism.html)`, `[`S`](-p-prism-of.html#S)`, `[`T`](-p-prism-of.html#T)`, `[`A`](-p-prism-of.html#A)`, `[`B`](-p-prism-of.html#B)`>` |
| [PPrismPartialOf](-p-prism-partial-of.html) | `typealias PPrismPartialOf<S, T, A> = Kind3<`[`ForPPrism`](-for-p-prism.html)`, `[`S`](-p-prism-partial-of.html#S)`, `[`T`](-p-prism-partial-of.html#T)`, `[`A`](-p-prism-partial-of.html#A)`>` |
| [PSetterKindedJ](-p-setter-kinded-j.html) | `typealias PSetterKindedJ<S, T, A, B> = HkJ4<`[`ForPSetter`](-for-p-setter.html)`, `[`S`](-p-setter-kinded-j.html#S)`, `[`T`](-p-setter-kinded-j.html#T)`, `[`A`](-p-setter-kinded-j.html#A)`, `[`B`](-p-setter-kinded-j.html#B)`>` |
| [PSetterOf](-p-setter-of.html) | `typealias PSetterOf<S, T, A, B> = Kind4<`[`ForPSetter`](-for-p-setter.html)`, `[`S`](-p-setter-of.html#S)`, `[`T`](-p-setter-of.html#T)`, `[`A`](-p-setter-of.html#A)`, `[`B`](-p-setter-of.html#B)`>` |
| [PSetterPartialOf](-p-setter-partial-of.html) | `typealias PSetterPartialOf<S, T, A> = Kind3<`[`ForPSetter`](-for-p-setter.html)`, `[`S`](-p-setter-partial-of.html#S)`, `[`T`](-p-setter-partial-of.html#T)`, `[`A`](-p-setter-partial-of.html#A)`>` |
| [PTraversalKindedJ](-p-traversal-kinded-j.html) | `typealias PTraversalKindedJ<S, T, A, B> = HkJ4<`[`ForPTraversal`](-for-p-traversal.html)`, `[`S`](-p-traversal-kinded-j.html#S)`, `[`T`](-p-traversal-kinded-j.html#T)`, `[`A`](-p-traversal-kinded-j.html#A)`, `[`B`](-p-traversal-kinded-j.html#B)`>` |
| [PTraversalOf](-p-traversal-of.html) | `typealias PTraversalOf<S, T, A, B> = Kind4<`[`ForPTraversal`](-for-p-traversal.html)`, `[`S`](-p-traversal-of.html#S)`, `[`T`](-p-traversal-of.html#T)`, `[`A`](-p-traversal-of.html#A)`, `[`B`](-p-traversal-of.html#B)`>` |
| [PTraversalPartialOf](-p-traversal-partial-of.html) | `typealias PTraversalPartialOf<S, T, A> = Kind3<`[`ForPTraversal`](-for-p-traversal.html)`, `[`S`](-p-traversal-partial-of.html#S)`, `[`T`](-p-traversal-partial-of.html#T)`, `[`A`](-p-traversal-partial-of.html#A)`>` |
| [Prism](-prism.html) | `typealias Prism<S, A> = `[`PPrism`](-p-prism/index.html)`<`[`S`](-prism.html#S)`, `[`S`](-prism.html#S)`, `[`A`](-prism.html#A)`, `[`A`](-prism.html#A)`>`<br>[Prism](-prism.html) is a type alias for [PPrism](-p-prism/index.html) which fixes the type arguments and restricts the [PPrism](-p-prism/index.html) to monomorphic updates. |
| [PrismKindedJ](-prism-kinded-j.html) | `typealias PrismKindedJ<S, A> = `[`PPrismKindedJ`](-p-prism-kinded-j.html)`<`[`S`](-prism-kinded-j.html#S)`, `[`S`](-prism-kinded-j.html#S)`, `[`A`](-prism-kinded-j.html#A)`, `[`A`](-prism-kinded-j.html#A)`>` |
| [PrismOf](-prism-of.html) | `typealias PrismOf<S, A> = `[`PPrismOf`](-p-prism-of.html)`<`[`S`](-prism-of.html#S)`, `[`S`](-prism-of.html#S)`, `[`A`](-prism-of.html#A)`, `[`A`](-prism-of.html#A)`>` |
| [PrismPartialOf](-prism-partial-of.html) | `typealias PrismPartialOf<S> = Kind<`[`ForPrism`](-for-prism.html)`, `[`S`](-prism-partial-of.html#S)`>` |
| [Setter](-setter.html) | `typealias Setter<S, A> = `[`PSetter`](-p-setter/index.html)`<`[`S`](-setter.html#S)`, `[`S`](-setter.html#S)`, `[`A`](-setter.html#A)`, `[`A`](-setter.html#A)`>`<br>[Setter](-setter.html) is a type alias for [PSetter](-p-setter/index.html) which fixes the type arguments and restricts the [PSetter](-p-setter/index.html) to monomorphic updates. |
| [SetterKindedJ](-setter-kinded-j.html) | `typealias SetterKindedJ<S, A> = `[`PSetterKindedJ`](-p-setter-kinded-j.html)`<`[`S`](-setter-kinded-j.html#S)`, `[`S`](-setter-kinded-j.html#S)`, `[`A`](-setter-kinded-j.html#A)`, `[`A`](-setter-kinded-j.html#A)`>` |
| [SetterOf](-setter-of.html) | `typealias SetterOf<S, A> = `[`PSetterOf`](-p-setter-of.html)`<`[`S`](-setter-of.html#S)`, `[`S`](-setter-of.html#S)`, `[`A`](-setter-of.html#A)`, `[`A`](-setter-of.html#A)`>` |
| [SetterPartialOf](-setter-partial-of.html) | `typealias SetterPartialOf<S> = Kind<`[`ForSetter`](-for-setter.html)`, `[`S`](-setter-partial-of.html#S)`>` |
| [Traversal](-traversal.html) | `typealias Traversal<S, A> = `[`PTraversal`](-p-traversal/index.html)`<`[`S`](-traversal.html#S)`, `[`S`](-traversal.html#S)`, `[`A`](-traversal.html#A)`, `[`A`](-traversal.html#A)`>`<br>[Traversal](-traversal.html) is a type alias for [PTraversal](-p-traversal/index.html) which fixes the type arguments and restricts the [PTraversal](-p-traversal/index.html) to monomorphic updates. |
| [TraversalKindedJ](-traversal-kinded-j.html) | `typealias TraversalKindedJ<S, A> = `[`PTraversalKindedJ`](-p-traversal-kinded-j.html)`<`[`S`](-traversal-kinded-j.html#S)`, `[`S`](-traversal-kinded-j.html#S)`, `[`A`](-traversal-kinded-j.html#A)`, `[`A`](-traversal-kinded-j.html#A)`>` |
| [TraversalOf](-traversal-of.html) | `typealias TraversalOf<S, A> = `[`PTraversalOf`](-p-traversal-of.html)`<`[`S`](-traversal-of.html#S)`, `[`S`](-traversal-of.html#S)`, `[`A`](-traversal-of.html#A)`, `[`A`](-traversal-of.html#A)`>` |
| [TraversalPartialOf](-traversal-partial-of.html) | `typealias TraversalPartialOf<S> = Kind<`[`ForTraversal`](-for-traversal.html)`, `[`S`](-traversal-partial-of.html#S)`>` |

### Extensions for External Classes

| [arrow.Kind](arrow.-kind/index.html) |  |
| [arrow.core.Either](arrow.core.-either/index.html) |  |
| [arrow.core.Id](arrow.core.-id/index.html) |  |
| [arrow.core.ListInstances](arrow.core.-list-instances/index.html) |  |
| [arrow.core.Option](arrow.core.-option/index.html) |  |
| [arrow.core.SetInstances](arrow.core.-set-instances/index.html) |  |
| [arrow.core.Try](arrow.core.-try/index.html) |  |
| [arrow.core.Tuple10](arrow.core.-tuple10/index.html) |  |
| [arrow.core.Tuple2](arrow.core.-tuple2/index.html) |  |
| [arrow.core.Tuple3](arrow.core.-tuple3/index.html) |  |
| [arrow.core.Tuple4](arrow.core.-tuple4/index.html) |  |
| [arrow.core.Tuple5](arrow.core.-tuple5/index.html) |  |
| [arrow.core.Tuple6](arrow.core.-tuple6/index.html) |  |
| [arrow.core.Tuple7](arrow.core.-tuple7/index.html) |  |
| [arrow.core.Tuple8](arrow.core.-tuple8/index.html) |  |
| [arrow.core.Tuple9](arrow.core.-tuple9/index.html) |  |
| [arrow.data.ListK](arrow.data.-list-k/index.html) |  |
| [arrow.data.MapK](arrow.data.-map-k/index.html) |  |
| [arrow.data.NonEmptyList](arrow.data.-non-empty-list/index.html) |  |
| [arrow.data.Validated](arrow.data.-validated/index.html) |  |
| [kotlin.String](kotlin.-string/index.html) |  |

### Functions

| [all](all.html) | `fun <S, T, A, B> `[`PPrism`](-p-prism/index.html)`<`[`S`](all.html#S)`, `[`T`](all.html#T)`, `[`A`](all.html#A)`, `[`B`](all.html#B)`>.all(s: `[`S`](all.html#S)`, p: (`[`A`](all.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if there is no focus or the focus satisfies the predicate |
| [assign](assign.html) | `fun <S, A> `[`Lens`](-lens.html)`<`[`S`](assign.html#S)`, `[`A`](assign.html#A)`>.assign(a: `[`A`](assign.html#A)`): State<`[`S`](assign.html#S)`, `[`A`](assign.html#A)`>`<br>Assign the focus [A](assign.html#A) viewed through the [Lens](-lens.html) and returns its *new* value.`fun <S, A> `[`Optional`](-optional.html)`<`[`S`](assign.html#S)`, `[`A`](assign.html#A)`>.assign(a: `[`A`](assign.html#A)`): State<`[`S`](assign.html#S)`, Option<`[`A`](assign.html#A)`>>`<br>Assign the focus [A](assign.html#A) viewed through the [Optional](-optional.html) and returns its *new* value.`fun <S, A> `[`Traversal`](-traversal.html)`<`[`S`](assign.html#S)`, `[`A`](assign.html#A)`>.assign(a: `[`A`](assign.html#A)`): State<`[`S`](assign.html#S)`, ListK<`[`A`](assign.html#A)`>>`<br>Assign the focus [A](assign.html#A) viewed through the [Traversal](-traversal.html) and returns its *new* value. |
| [assignOld](assign-old.html) | `fun <S, A> `[`Lens`](-lens.html)`<`[`S`](assign-old.html#S)`, `[`A`](assign-old.html#A)`>.assignOld(a: `[`A`](assign-old.html#A)`): State<`[`S`](assign-old.html#S)`, `[`A`](assign-old.html#A)`>`<br>Assign the value focus [A](assign-old.html#A) through the [Lens](-lens.html) and returns its *old* value.`fun <S, A> `[`Optional`](-optional.html)`<`[`S`](assign-old.html#S)`, `[`A`](assign-old.html#A)`>.assignOld(a: `[`A`](assign-old.html#A)`): State<`[`S`](assign-old.html#S)`, Option<`[`A`](assign-old.html#A)`>>`<br>Assign the value focus [A](assign-old.html#A) through the [Optional](-optional.html) and returns its *old* value.`fun <S, A> `[`Traversal`](-traversal.html)`<`[`S`](assign-old.html#S)`, `[`A`](assign-old.html#A)`>.assignOld(a: `[`A`](assign-old.html#A)`): State<`[`S`](assign-old.html#S)`, ListK<`[`A`](assign-old.html#A)`>>`<br>Assign the focus [A](assign-old.html#A) viewed through the [Traversal](-traversal.html) and returns its *old* value. |
| [assign_](assign_.html) | `fun <S, A> `[`Lens`](-lens.html)`<`[`S`](assign_.html#S)`, `[`A`](assign_.html#A)`>.assign_(a: `[`A`](assign_.html#A)`): State<`[`S`](assign_.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Assign the focus [A](assign_.html#A) viewed through the [Lens](-lens.html) and ignores both values.`fun <S, A> `[`Optional`](-optional.html)`<`[`S`](assign_.html#S)`, `[`A`](assign_.html#A)`>.assign_(a: `[`A`](assign_.html#A)`): State<`[`S`](assign_.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Assign the focus [A](assign_.html#A) viewed through the [Optional](-optional.html) and ignores both values.`fun <S, A> `[`Setter`](-setter.html)`<`[`S`](assign_.html#S)`, `[`A`](assign_.html#A)`>.assign_(a: `[`A`](assign_.html#A)`): State<`[`S`](assign_.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Set the focus [A](assign_.html#A) referenced through the [Setter](-setter.html).`fun <S, A> `[`Traversal`](-traversal.html)`<`[`S`](assign_.html#S)`, `[`A`](assign_.html#A)`>.assign_(a: `[`A`](assign_.html#A)`): State<`[`S`](assign_.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Assign the focus [A](assign_.html#A) viewed through the [Traversal](-traversal.html) and ignores both values. |
| [exist](exist.html) | `fun <S, T, A, B> `[`PPrism`](-p-prism/index.html)`<`[`S`](exist.html#S)`, `[`T`](exist.html#T)`, `[`A`](exist.html#A)`, `[`B`](exist.html#B)`>.exist(s: `[`S`](exist.html#S)`, p: (`[`A`](exist.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if there is a focus and it satisfies the predicate |
| [find](find.html) | `fun <S, T, A, B> `[`PPrism`](-p-prism/index.html)`<`[`S`](find.html#S)`, `[`T`](find.html#T)`, `[`A`](find.html#A)`, `[`B`](find.html#B)`>.find(s: `[`S`](find.html#S)`, p: (`[`A`](find.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): Option<`[`A`](find.html#A)`>`<br>Find the focus that satisfies the predicate |
| [left](left.html) | `fun <S, T, A, B, C> `[`PPrism`](-p-prism/index.html)`<`[`S`](left.html#S)`, `[`T`](left.html#T)`, `[`A`](left.html#A)`, `[`B`](left.html#B)`>.left(): `[`PPrism`](-p-prism/index.html)`<Either<`[`S`](left.html#S)`, `[`C`](left.html#C)`>, Either<`[`T`](left.html#T)`, `[`C`](left.html#C)`>, Either<`[`A`](left.html#A)`, `[`C`](left.html#C)`>, Either<`[`B`](left.html#B)`, `[`C`](left.html#C)`>>`<br>Create a sum of the [PPrism](-p-prism/index.html) and a type [C](left.html#C) |
| [lift](lift.html) | `fun <S, T, A, B> `[`PPrism`](-p-prism/index.html)`<`[`S`](lift.html#S)`, `[`T`](lift.html#T)`, `[`A`](lift.html#A)`, `[`B`](lift.html#B)`>.lift(f: (`[`A`](lift.html#A)`) -> `[`B`](lift.html#B)`): (`[`S`](lift.html#S)`) -> `[`T`](lift.html#T)<br>Lift a function [f](lift.html#arrow.optics$lift(arrow.optics.PPrism((arrow.optics.lift.S, arrow.optics.lift.T, arrow.optics.lift.A, arrow.optics.lift.B)), kotlin.Function1((arrow.optics.lift.A, arrow.optics.lift.B)))/f): `(A) -> B to the context of `S`: `(S) -&gt; T` |
| [liftOption](lift-option.html) | `fun <S, T, A, B> `[`PPrism`](-p-prism/index.html)`<`[`S`](lift-option.html#S)`, `[`T`](lift-option.html#T)`, `[`A`](lift-option.html#A)`, `[`B`](lift-option.html#B)`>.liftOption(f: (`[`A`](lift-option.html#A)`) -> `[`B`](lift-option.html#B)`): (`[`S`](lift-option.html#S)`) -> Option<`[`T`](lift-option.html#T)`>`<br>Lift a function [f](lift-option.html#arrow.optics$liftOption(arrow.optics.PPrism((arrow.optics.liftOption.S, arrow.optics.liftOption.T, arrow.optics.liftOption.A, arrow.optics.liftOption.B)), kotlin.Function1((arrow.optics.liftOption.A, arrow.optics.liftOption.B)))/f): `(A) -> B to the context of `S`: `(S) -&gt; Option` |
| [modify](modify.html) | `fun <S, T, A, B> `[`PPrism`](-p-prism/index.html)`<`[`S`](modify.html#S)`, `[`T`](modify.html#T)`, `[`A`](modify.html#A)`, `[`B`](modify.html#B)`>.modify(s: `[`S`](modify.html#S)`, f: (`[`A`](modify.html#A)`) -> `[`B`](modify.html#B)`): `[`T`](modify.html#T)<br>Modify the focus of a [PPrism](-p-prism/index.html) with a function |
| [modifyOption](modify-option.html) | `fun <S, T, A, B> `[`PPrism`](-p-prism/index.html)`<`[`S`](modify-option.html#S)`, `[`T`](modify-option.html#T)`, `[`A`](modify-option.html#A)`, `[`B`](modify-option.html#B)`>.modifyOption(s: `[`S`](modify-option.html#S)`, f: (`[`A`](modify-option.html#A)`) -> `[`B`](modify-option.html#B)`): Option<`[`T`](modify-option.html#T)`>`<br>Modify the focus of a [PPrism](-p-prism/index.html) with a function |
| [right](right.html) | `fun <S, T, A, B, C> `[`PPrism`](-p-prism/index.html)`<`[`S`](right.html#S)`, `[`T`](right.html#T)`, `[`A`](right.html#A)`, `[`B`](right.html#B)`>.right(): `[`PPrism`](-p-prism/index.html)`<Either<`[`C`](right.html#C)`, `[`S`](right.html#S)`>, Either<`[`C`](right.html#C)`, `[`T`](right.html#T)`>, Either<`[`C`](right.html#C)`, `[`A`](right.html#A)`>, Either<`[`C`](right.html#C)`, `[`B`](right.html#B)`>>`<br>Create a sum of a type [C](right.html#C) and the [PPrism](-p-prism/index.html) |
| [update](update.html) | `fun <S, A> `[`Lens`](-lens.html)`<`[`S`](update.html#S)`, `[`A`](update.html#A)`>.update(f: (`[`A`](update.html#A)`) -> `[`A`](update.html#A)`): State<`[`S`](update.html#S)`, `[`A`](update.html#A)`>`<br>Update the focus [A](update.html#A) viewed through the [Lens](-lens.html) and returns its *new* value.`fun <S, A> `[`Optional`](-optional.html)`<`[`S`](update.html#S)`, `[`A`](update.html#A)`>.update(f: (`[`A`](update.html#A)`) -> `[`A`](update.html#A)`): State<`[`S`](update.html#S)`, Option<`[`A`](update.html#A)`>>`<br>Update the focus [A](update.html#A) viewed through the [Optional](-optional.html) and returns its *new* value.`fun <S, A> `[`Traversal`](-traversal.html)`<`[`S`](update.html#S)`, `[`A`](update.html#A)`>.update(f: (`[`A`](update.html#A)`) -> `[`A`](update.html#A)`): State<`[`S`](update.html#S)`, ListK<`[`A`](update.html#A)`>>`<br>Update the focus [A](update.html#A) viewed through the [Traversal](-traversal.html) and returns its *new* value. |
| [updateOld](update-old.html) | `fun <S, A> `[`Lens`](-lens.html)`<`[`S`](update-old.html#S)`, `[`A`](update-old.html#A)`>.updateOld(f: (`[`A`](update-old.html#A)`) -> `[`A`](update-old.html#A)`): State<`[`S`](update-old.html#S)`, `[`A`](update-old.html#A)`>`<br>Update the focus [A](update-old.html#A) viewed through the [Lens](-lens.html) and returns its *old* value.`fun <S, A> `[`Optional`](-optional.html)`<`[`S`](update-old.html#S)`, `[`A`](update-old.html#A)`>.updateOld(f: (`[`A`](update-old.html#A)`) -> `[`A`](update-old.html#A)`): State<`[`S`](update-old.html#S)`, Option<`[`A`](update-old.html#A)`>>`<br>Update the focus [A](update-old.html#A) viewed through the [Optional](-optional.html) and returns its *old* value.`fun <S, A> `[`Traversal`](-traversal.html)`<`[`S`](update-old.html#S)`, `[`A`](update-old.html#A)`>.updateOld(f: (`[`A`](update-old.html#A)`) -> `[`A`](update-old.html#A)`): State<`[`S`](update-old.html#S)`, ListK<`[`A`](update-old.html#A)`>>`<br>Update the focus [A](update-old.html#A) viewed through the [Traversal](-traversal.html) and returns its *old* value. |
| [update_](update_.html) | `fun <S, A> `[`Lens`](-lens.html)`<`[`S`](update_.html#S)`, `[`A`](update_.html#A)`>.update_(f: (`[`A`](update_.html#A)`) -> `[`A`](update_.html#A)`): State<`[`S`](update_.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Modify the focus [A](update_.html#A) viewed through the [Lens](-lens.html) and ignores both values.`fun <S, A> `[`Optional`](-optional.html)`<`[`S`](update_.html#S)`, `[`A`](update_.html#A)`>.update_(f: (`[`A`](update_.html#A)`) -> `[`A`](update_.html#A)`): State<`[`S`](update_.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Update the focus [A](update_.html#A) viewed through the [Optional](-optional.html) and ignores both values.`fun <S, A> `[`Setter`](-setter.html)`<`[`S`](update_.html#S)`, `[`A`](update_.html#A)`>.update_(f: (`[`A`](update_.html#A)`) -> `[`A`](update_.html#A)`): State<`[`S`](update_.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Update the focus [A](update_.html#A) referenced through the [Setter](-setter.html).`fun <S, A> `[`Traversal`](-traversal.html)`<`[`S`](update_.html#S)`, `[`A`](update_.html#A)`>.update_(f: (`[`A`](update_.html#A)`) -> `[`A`](update_.html#A)`): State<`[`S`](update_.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Update the focus [A](update_.html#A) viewed through the [Traversal](-traversal.html) and ignores both values |

### Companion Object Functions

| [invoke](invoke.html) | `operator fun <S, A> PPrism.Companion.invoke(getOption: (`[`S`](invoke.html#S)`) -> Option<`[`A`](invoke.html#A)`>, reverseGet: (`[`A`](invoke.html#A)`) -> `[`S`](invoke.html#S)`): `[`Prism`](-prism.html)`<`[`S`](invoke.html#S)`, `[`A`](invoke.html#A)`>`<br>Invoke operator overload to create a [PPrism](-p-prism/index.html) of type `S` with a focus `A` where `A` is a subtype of `S` Can also be used to construct [Prism](-prism.html) |

