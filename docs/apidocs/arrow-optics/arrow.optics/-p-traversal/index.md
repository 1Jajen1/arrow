---
title: PTraversal - arrow-optics
---

[arrow-optics](../../index.html) / [arrow.optics](../index.html) / [PTraversal](./index.html)

# PTraversal

`@higherkind interface PTraversal<S, T, A, B> : `[`PTraversalOf`](../-p-traversal-of.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>`

A [Traversal](../-traversal.html) is an optic that allows to see into a structure with 0 to N foci.

[Traversal](../-traversal.html) is a generalisation of [arrow.Traverse](#) and can be seen as a representation of modifyF.
all methods are written in terms of modifyF

### Parameters

`S` - the source of a [PTraversal](./index.html)

`T` - the modified source of a [PTraversal](./index.html)

`A` - the target of a [PTraversal](./index.html)

`B` - the modified target of a [PTraversal](./index.html)

### Functions

| [asFold](as-fold.html) | `open fun asFold(): `[`Fold`](../-fold/index.html)`<`[`S`](index.html#S)`, `[`A`](index.html#A)`>` |
| [asSetter](as-setter.html) | `open fun asSetter(): `[`PSetter`](../-p-setter/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>` |
| [choice](choice.html) | `open fun <U, V> choice(other: `[`PTraversal`](./index.html)`<`[`U`](choice.html#U)`, `[`V`](choice.html#V)`, `[`A`](index.html#A)`, `[`B`](index.html#B)`>): `[`PTraversal`](./index.html)`<Either<`[`S`](index.html#S)`, `[`U`](choice.html#U)`>, Either<`[`T`](index.html#T)`, `[`V`](choice.html#V)`>, `[`A`](index.html#A)`, `[`B`](index.html#B)`>` |
| [combineAll](combine-all.html) | `open fun combineAll(M: Monoid<`[`A`](index.html#A)`>, s: `[`S`](index.html#S)`): `[`A`](index.html#A)<br>Alias for fold. |
| [compose](compose.html) | `open infix fun <C, D> compose(other: `[`PTraversal`](./index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PTraversal`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PTraversal](./index.html) with a [PTraversal](./index.html)`open infix fun <C, D> compose(other: `[`PSetter`](../-p-setter/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PSetter`](../-p-setter/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PTraversal](./index.html) with a [PSetter](../-p-setter/index.html)`open infix fun <C, D> compose(other: `[`POptional`](../-p-optional/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PTraversal`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PTraversal](./index.html) with a [POptional](../-p-optional/index.html)`open infix fun <C, D> compose(other: `[`PLens`](../-p-lens/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PTraversal`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PTraversal](./index.html) with a [PLens](../-p-lens/index.html)`open infix fun <C, D> compose(other: `[`PPrism`](../-p-prism/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PTraversal`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PTraversal](./index.html) with a [PPrism](../-p-prism/index.html)`open infix fun <C, D> compose(other: `[`PIso`](../-p-iso/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>): `[`PTraversal`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](compose.html#C)`, `[`D`](compose.html#D)`>`<br>Compose a [PTraversal](./index.html) with a [PIso](../-p-iso/index.html)`open infix fun <C> compose(other: `[`Fold`](../-fold/index.html)`<`[`A`](index.html#A)`, `[`C`](compose.html#C)`>): `[`Fold`](../-fold/index.html)`<`[`S`](index.html#S)`, `[`C`](compose.html#C)`>`<br>Compose a [PTraversal](./index.html) with a [Fold](../-fold/index.html) |
| [exist](exist.html) | `open fun exist(s: `[`S`](index.html#S)`, p: (`[`A`](index.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check whether at least one element satisfies the predicate. |
| [extract](extract.html) | `open fun extract(): State<`[`S`](index.html#S)`, ListK<`[`A`](index.html#A)`>>`<br>Extracts the focus [A](index.html#A) viewed through the [PTraversal](./index.html). |
| [extractMap](extract-map.html) | `open fun <C> extractMap(f: (`[`A`](index.html#A)`) -> `[`C`](extract-map.html#C)`): State<`[`S`](index.html#S)`, ListK<`[`C`](extract-map.html#C)`>>`<br>Extract and map the focus [A](index.html#A) viewed through the [PTraversal](./index.html) and applies [f](extract-map.html#arrow.optics.PTraversal$extractMap(kotlin.Function1((arrow.optics.PTraversal.A, arrow.optics.PTraversal.extractMap.C)))/f) to it. |
| [find](find.html) | `open fun find(s: `[`S`](index.html#S)`, p: (`[`A`](index.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): Option<`[`A`](index.html#A)`>`<br>Find the first target matching the predicate |
| [fold](fold.html) | `open fun fold(M: Monoid<`[`A`](index.html#A)`>, s: `[`S`](index.html#S)`): `[`A`](index.html#A)<br>Fold using the given [Monoid](#) instance. |
| [foldMap](fold-map.html) | `open fun <R> foldMap(M: Monoid<`[`R`](fold-map.html#R)`>, s: `[`S`](index.html#S)`, f: (`[`A`](index.html#A)`) -> `[`R`](fold-map.html#R)`): `[`R`](fold-map.html#R)<br>`open fun <R> foldMap(s: `[`S`](index.html#S)`, f: (`[`A`](index.html#A)`) -> `[`R`](fold-map.html#R)`, M: Monoid<`[`R`](fold-map.html#R)`>): `[`R`](fold-map.html#R)<br>Map each target to a Monoid and combine the results |
| [forall](forall.html) | `open fun forall(s: `[`S`](index.html#S)`, p: (`[`A`](index.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if forall targets satisfy the predicate |
| [getAll](get-all.html) | `open fun getAll(s: `[`S`](index.html#S)`): ListK<`[`A`](index.html#A)`>`<br>Get all foci of the [PTraversal](./index.html) |
| [headOption](head-option.html) | `open fun headOption(s: `[`S`](index.html#S)`): Option<`[`A`](index.html#A)`>`<br>Find the first target or [Option.None](#) if no targets |
| [isEmpty](is-empty.html) | `open fun isEmpty(s: `[`S`](index.html#S)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if there is no target |
| [lastOption](last-option.html) | `open fun lastOption(s: `[`S`](index.html#S)`): Option<`[`A`](index.html#A)`>`<br>Find the first target or [Option.None](#) if no targets |
| [modify](modify.html) | `open fun modify(s: `[`S`](index.html#S)`, f: (`[`A`](index.html#A)`) -> `[`B`](index.html#B)`): `[`T`](index.html#T)<br>Modify polymorphically the target of a [PTraversal](./index.html) with a function [f](modify.html#arrow.optics.PTraversal$modify(arrow.optics.PTraversal.S, kotlin.Function1((arrow.optics.PTraversal.A, arrow.optics.PTraversal.B)))/f) |
| [modifyF](modify-f.html) | `abstract fun <F> modifyF(FA: Applicative<`[`F`](modify-f.html#F)`>, s: `[`S`](index.html#S)`, f: (`[`A`](index.html#A)`) -> Kind<`[`F`](modify-f.html#F)`, `[`B`](index.html#B)`>): Kind<`[`F`](modify-f.html#F)`, `[`T`](index.html#T)`>` |
| [nonEmpty](non-empty.html) | `open fun nonEmpty(s: `[`S`](index.html#S)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if there is at least one target |
| [plus](plus.html) | `open operator fun <C, D> plus(other: `[`PTraversal`](./index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PTraversal`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>Plus operator overload to compose [PTraversal](./index.html) with other optics`open operator fun <C, D> plus(other: `[`PSetter`](../-p-setter/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PSetter`](../-p-setter/index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C, D> plus(other: `[`POptional`](../-p-optional/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PTraversal`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C, D> plus(other: `[`PLens`](../-p-lens/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PTraversal`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C, D> plus(other: `[`PPrism`](../-p-prism/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PTraversal`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C, D> plus(other: `[`PIso`](../-p-iso/index.html)`<`[`A`](index.html#A)`, `[`B`](index.html#B)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>): `[`PTraversal`](./index.html)`<`[`S`](index.html#S)`, `[`T`](index.html#T)`, `[`C`](plus.html#C)`, `[`D`](plus.html#D)`>`<br>`open operator fun <C> plus(other: `[`Fold`](../-fold/index.html)`<`[`A`](index.html#A)`, `[`C`](plus.html#C)`>): `[`Fold`](../-fold/index.html)`<`[`S`](index.html#S)`, `[`C`](plus.html#C)`>` |
| [set](set.html) | `open fun set(s: `[`S`](index.html#S)`, b: `[`B`](index.html#B)`): `[`T`](index.html#T)<br>Set polymorphically the target of a [PTraversal](./index.html) with a value |
| [size](size.html) | `open fun size(s: `[`S`](index.html#S)`): `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>Calculate the number of targets in the [PTraversal](./index.html) |
| [toState](to-state.html) | `open fun toState(): State<`[`S`](index.html#S)`, ListK<`[`A`](index.html#A)`>>`<br>Transforms a [PTraversal](./index.html) into a [State](#). Alias for [extract](extract.html). |

### Companion Object Functions

| [codiagonal](codiagonal.html) | `fun <S> codiagonal(): `[`Traversal`](../-traversal.html)`<Either<`[`S`](codiagonal.html#S)`, `[`S`](codiagonal.html#S)`>, `[`S`](codiagonal.html#S)`>` |
| [fromTraversable](from-traversable.html) | `fun <T, A, B> fromTraversable(TT: Traverse<`[`T`](from-traversable.html#T)`>): `[`PTraversal`](./index.html)`<Kind<`[`T`](from-traversable.html#T)`, `[`A`](from-traversable.html#A)`>, Kind<`[`T`](from-traversable.html#T)`, `[`B`](from-traversable.html#B)`>, `[`A`](from-traversable.html#A)`, `[`B`](from-traversable.html#B)`>`<br>Construct a [PTraversal](./index.html) from a [Traverse](#) instance. |
| [id](id.html) | `fun <S> id(): `[`PTraversal`](./index.html)`<`[`S`](id.html#S)`, `[`S`](id.html#S)`, `[`S`](id.html#S)`, `[`S`](id.html#S)`>` |
| [invoke](invoke.html) | `operator fun <S, T, A, B> invoke(get1: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get2: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, set: (`[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`S`](invoke.html#S)`) -> `[`T`](invoke.html#T)`): `[`PTraversal`](./index.html)`<`[`S`](invoke.html#S)`, `[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`, `[`B`](invoke.html#B)`>`<br>[PTraversal](./index.html) constructor from multiple getters of the same source.`operator fun <S, T, A, B> invoke(get1: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get2: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get3: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, set: (`[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`S`](invoke.html#S)`) -> `[`T`](invoke.html#T)`): `[`PTraversal`](./index.html)`<`[`S`](invoke.html#S)`, `[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`, `[`B`](invoke.html#B)`>`<br>`operator fun <S, T, A, B> invoke(get1: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get2: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get3: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get4: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, set: (`[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`S`](invoke.html#S)`) -> `[`T`](invoke.html#T)`): `[`PTraversal`](./index.html)`<`[`S`](invoke.html#S)`, `[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`, `[`B`](invoke.html#B)`>`<br>`operator fun <S, T, A, B> invoke(get1: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get2: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get3: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get4: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get5: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, set: (`[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`S`](invoke.html#S)`) -> `[`T`](invoke.html#T)`): `[`PTraversal`](./index.html)`<`[`S`](invoke.html#S)`, `[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`, `[`B`](invoke.html#B)`>`<br>`operator fun <S, T, A, B> invoke(get1: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get2: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get3: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get4: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get5: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get6: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, set: (`[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`S`](invoke.html#S)`) -> `[`T`](invoke.html#T)`): `[`PTraversal`](./index.html)`<`[`S`](invoke.html#S)`, `[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`, `[`B`](invoke.html#B)`>`<br>`operator fun <S, T, A, B> invoke(get1: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get2: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get3: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get4: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get5: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get6: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get7: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, set: (`[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`S`](invoke.html#S)`) -> `[`T`](invoke.html#T)`): `[`PTraversal`](./index.html)`<`[`S`](invoke.html#S)`, `[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`, `[`B`](invoke.html#B)`>`<br>`operator fun <S, T, A, B> invoke(get1: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get2: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get3: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get4: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get5: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get6: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get7: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get8: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, set: (`[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`S`](invoke.html#S)`) -> `[`T`](invoke.html#T)`): `[`PTraversal`](./index.html)`<`[`S`](invoke.html#S)`, `[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`, `[`B`](invoke.html#B)`>`<br>`operator fun <S, T, A, B> invoke(get1: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get2: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get3: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get4: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get5: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get6: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get7: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get8: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get9: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, set: (`[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`S`](invoke.html#S)`) -> `[`T`](invoke.html#T)`): `[`PTraversal`](./index.html)`<`[`S`](invoke.html#S)`, `[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`, `[`B`](invoke.html#B)`>`<br>`operator fun <S, T, A, B> invoke(get1: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get2: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get3: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get4: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get5: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get6: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get7: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get8: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get9: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, get10: (`[`S`](invoke.html#S)`) -> `[`A`](invoke.html#A)`, set: (`[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`B`](invoke.html#B)`, `[`S`](invoke.html#S)`) -> `[`T`](invoke.html#T)`): `[`PTraversal`](./index.html)`<`[`S`](invoke.html#S)`, `[`T`](invoke.html#T)`, `[`A`](invoke.html#A)`, `[`B`](invoke.html#B)`>` |
| [void](void.html) | `fun <S, A> void(): `[`PTraversal`](./index.html)`<`[`S`](void.html#S)`, `[`S`](void.html#S)`, `[`A`](void.html#A)`, `[`A`](void.html#A)`>`<br>[PTraversal](./index.html) that points to nothing |

### Extension Properties

| [every](../../arrow.optics.typeclasses/-each/every.html) | `open val <T> `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.typeclasses/-each/every.html#T)`, `[`S`](../../arrow.optics.typeclasses/-each/index.html#S)`>.every: `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.typeclasses/-each/every.html#T)`, `[`A`](../../arrow.optics.typeclasses/-each/index.html#A)`>`<br>DSL to compose [Each](../../arrow.optics.typeclasses/-each/index.html) with a [Traversal](../-traversal.html) for a structure [S](../../arrow.optics.typeclasses/-each/index.html#S) to see all its foci [A](../../arrow.optics.typeclasses/-each/index.html#A) |
| [some](../../arrow.optics.dsl/some.html) | `val <T, S> `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.dsl/some.html#T)`, Option<`[`S`](../../arrow.optics.dsl/some.html#S)`>>.some: `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.dsl/some.html#T)`, `[`S`](../../arrow.optics.dsl/some.html#S)`>`<br>DSL to compose a [Prism](../-prism.html) with focus [arrow.core.Some](#) with a [Traversal](../-traversal.html) with a focus of [Option](#)&lt;[S](../../arrow.optics.dsl/some.html#S)&gt; |

### Extension Functions

| [assign](../assign.html) | `fun <S, A> `[`Traversal`](../-traversal.html)`<`[`S`](../assign.html#S)`, `[`A`](../assign.html#A)`>.assign(a: `[`A`](../assign.html#A)`): State<`[`S`](../assign.html#S)`, ListK<`[`A`](../assign.html#A)`>>`<br>Assign the focus [A](../assign.html#A) viewed through the [Traversal](../-traversal.html) and returns its *new* value. |
| [assignOld](../assign-old.html) | `fun <S, A> `[`Traversal`](../-traversal.html)`<`[`S`](../assign-old.html#S)`, `[`A`](../assign-old.html#A)`>.assignOld(a: `[`A`](../assign-old.html#A)`): State<`[`S`](../assign-old.html#S)`, ListK<`[`A`](../assign-old.html#A)`>>`<br>Assign the focus [A](../assign-old.html#A) viewed through the [Traversal](../-traversal.html) and returns its *old* value. |
| [assign_](../assign_.html) | `fun <S, A> `[`Traversal`](../-traversal.html)`<`[`S`](../assign_.html#S)`, `[`A`](../assign_.html#A)`>.assign_(a: `[`A`](../assign_.html#A)`): State<`[`S`](../assign_.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Assign the focus [A](../assign_.html#A) viewed through the [Traversal](../-traversal.html) and ignores both values. |
| [at](../../arrow.optics.dsl/at.html) | `fun <T, S, I, A> `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.dsl/at.html#T)`, `[`S`](../../arrow.optics.dsl/at.html#S)`>.at(AT: `[`At`](../../arrow.optics.typeclasses/-at/index.html)`<`[`S`](../../arrow.optics.dsl/at.html#S)`, `[`I`](../../arrow.optics.dsl/at.html#I)`, `[`A`](../../arrow.optics.dsl/at.html#A)`>, i: `[`I`](../../arrow.optics.dsl/at.html#I)`): `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.dsl/at.html#T)`, `[`A`](../../arrow.optics.dsl/at.html#A)`>`<br>DSL to compose [At](../../arrow.optics.typeclasses/-at/index.html) with a [Traversal](../-traversal.html) for a structure [S](../../arrow.optics.dsl/at.html#S) to focus in on [A](../../arrow.optics.dsl/at.html#A) at given index [I](../../arrow.optics.dsl/at.html#I). |
| [every](../../arrow.optics.dsl/every.html) | `fun <T, S, A> `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.dsl/every.html#T)`, `[`S`](../../arrow.optics.dsl/every.html#S)`>.every(EA: `[`Each`](../../arrow.optics.typeclasses/-each/index.html)`<`[`S`](../../arrow.optics.dsl/every.html#S)`, `[`A`](../../arrow.optics.dsl/every.html#A)`>): `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.dsl/every.html#T)`, `[`A`](../../arrow.optics.dsl/every.html#A)`>`<br>DSL to compose [Each](../../arrow.optics.typeclasses/-each/index.html) with a [Traversal](../-traversal.html) for a structure [S](../../arrow.optics.dsl/every.html#S) to see all its foci [A](../../arrow.optics.dsl/every.html#A) |
| [index](../../arrow.optics.dsl/--index--.html) | `fun <T, S, I, A> `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.dsl/--index--.html#T)`, `[`S`](../../arrow.optics.dsl/--index--.html#S)`>.index(ID: `[`Index`](../../arrow.optics.typeclasses/-index/index.html)`<`[`S`](../../arrow.optics.dsl/--index--.html#S)`, `[`I`](../../arrow.optics.dsl/--index--.html#I)`, `[`A`](../../arrow.optics.dsl/--index--.html#A)`>, i: `[`I`](../../arrow.optics.dsl/--index--.html#I)`): `[`Traversal`](../-traversal.html)`<`[`T`](../../arrow.optics.dsl/--index--.html#T)`, `[`A`](../../arrow.optics.dsl/--index--.html#A)`>`<br>DSL to compose [Index](../../arrow.optics.typeclasses/-index/index.html) with a [Traversal](../-traversal.html) for a structure [S](../../arrow.optics.dsl/--index--.html#S) to focus in on [A](../../arrow.optics.dsl/--index--.html#A) at given index [I](../../arrow.optics.dsl/--index--.html#I) |
| [update](../update.html) | `fun <S, A> `[`Traversal`](../-traversal.html)`<`[`S`](../update.html#S)`, `[`A`](../update.html#A)`>.update(f: (`[`A`](../update.html#A)`) -> `[`A`](../update.html#A)`): State<`[`S`](../update.html#S)`, ListK<`[`A`](../update.html#A)`>>`<br>Update the focus [A](../update.html#A) viewed through the [Traversal](../-traversal.html) and returns its *new* value. |
| [updateOld](../update-old.html) | `fun <S, A> `[`Traversal`](../-traversal.html)`<`[`S`](../update-old.html#S)`, `[`A`](../update-old.html#A)`>.updateOld(f: (`[`A`](../update-old.html#A)`) -> `[`A`](../update-old.html#A)`): State<`[`S`](../update-old.html#S)`, ListK<`[`A`](../update-old.html#A)`>>`<br>Update the focus [A](../update-old.html#A) viewed through the [Traversal](../-traversal.html) and returns its *old* value. |
| [update_](../update_.html) | `fun <S, A> `[`Traversal`](../-traversal.html)`<`[`S`](../update_.html#S)`, `[`A`](../update_.html#A)`>.update_(f: (`[`A`](../update_.html#A)`) -> `[`A`](../update_.html#A)`): State<`[`S`](../update_.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Update the focus [A](../update_.html#A) viewed through the [Traversal](../-traversal.html) and ignores both values |

