---
title: StateT - arrow-data
---

[arrow-data](../../index.html) / [arrow.data](../index.html) / [StateT](./index.html)

# StateT

`@higherkind class StateT<F, S, A> : `[`StateTOf`](../-state-t-of.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`A`](index.html#A)`>, `[`StateTKindedJ`](../-state-t-kinded-j.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`A`](index.html#A)`>`

`StateT<F, S, A>` is a stateful computation within a context `F` yielding
a value of type `A`. i.e. StateT&lt;EitherPartialOf, S, A&gt; = Either&lt;E, State&lt;S, A&gt;&gt;

### Parameters

`F` - the context that wraps the stateful computation.

`S` - the state we are preforming computation upon.

`A` - current value of computation.

`runF` - the stateful computation that is wrapped and managed by `StateT`

### Constructors

| [&lt;init&gt;](-init-.html) | `StateT(runF: `[`StateTFunOf`](../-state-t-fun-of.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`A`](index.html#A)`>)`<br>`StateT<F, S, A>` is a stateful computation within a context `F` yielding a value of type `A`. i.e. StateT&lt;EitherPartialOf, S, A&gt; = Either&lt;E, State&lt;S, A&gt;&gt; |

### Properties

| [runF](run-f.html) | `val runF: `[`StateTFunOf`](../-state-t-fun-of.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`A`](index.html#A)`>`<br>the stateful computation that is wrapped and managed by `StateT` |

### Functions

| [ap](ap.html) | `fun <B> ap(MF: Monad<`[`F`](index.html#F)`>, ff: `[`StateTOf`](../-state-t-of.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, (`[`A`](index.html#A)`) -> `[`B`](ap.html#B)`>): `[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`B`](ap.html#B)`>`<br>Apply a function `(S) -> B` that operates within the [StateT](./index.html) context. |
| [combineK](combine-k.html) | `fun combineK(MF: Monad<`[`F`](index.html#F)`>, SF: SemigroupK<`[`F`](index.html#F)`>, y: `[`StateTOf`](../-state-t-of.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`A`](index.html#A)`>): `[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`A`](index.html#A)`>`<br>Combine two [StateT](./index.html) objects using an instance of [SemigroupK](#) for [F](index.html#F). |
| [flatMap](flat-map.html) | `fun <B> flatMap(MF: Monad<`[`F`](index.html#F)`>, fas: (`[`A`](index.html#A)`) -> `[`StateTOf`](../-state-t-of.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`B`](flat-map.html#B)`>): `[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`B`](flat-map.html#B)`>`<br>Map the value [A](index.html#A) to another [StateT](./index.html) object for the same state [S](index.html#S) and context [F](index.html#F) and flatten the structure. |
| [flatMapF](flat-map-f.html) | `fun <B> flatMapF(MF: Monad<`[`F`](index.html#F)`>, faf: (`[`A`](index.html#A)`) -> Kind<`[`F`](index.html#F)`, `[`B`](flat-map-f.html#B)`>): `[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`B`](flat-map-f.html#B)`>`<br>Map the value [A](index.html#A) to a arbitrary type [B](flat-map-f.html#B) that is within the context of [F](index.html#F). |
| [map](map.html) | `fun <B> map(FF: Functor<`[`F`](index.html#F)`>, f: (`[`A`](index.html#A)`) -> `[`B`](map.html#B)`): `[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`B`](map.html#B)`>`<br>Map current value [A](index.html#A) given a function [f](map.html#arrow.data.StateT$map(arrow.typeclasses.Functor((arrow.data.StateT.F)), kotlin.Function1((arrow.data.StateT.A, arrow.data.StateT.map.B)))/f). |
| [map2](map2.html) | `fun <B, Z> map2(MF: Monad<`[`F`](index.html#F)`>, sb: `[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`B`](map2.html#B)`>, fn: (`[`A`](index.html#A)`, `[`B`](map2.html#B)`) -> `[`Z`](map2.html#Z)`): `[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`Z`](map2.html#Z)`>`<br>Combine with another [StateT](./index.html) of same context [F](index.html#F) and state [S](index.html#S). |
| [map2Eval](map2-eval.html) | `fun <B, Z> map2Eval(MF: Monad<`[`F`](index.html#F)`>, sb: Eval<`[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`B`](map2-eval.html#B)`>>, fn: (`[`A`](index.html#A)`, `[`B`](map2-eval.html#B)`) -> `[`Z`](map2-eval.html#Z)`): Eval<`[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`Z`](map2-eval.html#Z)`>>`<br>Controlled combination of [StateT](./index.html) that is of same context [F](index.html#F) and state [S](index.html#S) using [Eval](#). |
| [product](product.html) | `fun <B> product(MF: Monad<`[`F`](index.html#F)`>, sb: `[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`B`](product.html#B)`>): `[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, Tuple2<`[`A`](index.html#A)`, `[`B`](product.html#B)`>>`<br>Create a product of the value types of [StateT](./index.html). |
| [run](run.html) | `fun run(MF: Monad<`[`F`](index.html#F)`>, initial: `[`S`](index.html#S)`): Kind<`[`F`](index.html#F)`, Tuple2<`[`S`](index.html#S)`, `[`A`](index.html#A)`>>`<br>Run the stateful computation within the context `F`. |
| [runA](run-a.html) | `fun runA(MF: Monad<`[`F`](index.html#F)`>, s: `[`S`](index.html#S)`): Kind<`[`F`](index.html#F)`, `[`A`](index.html#A)`>`<br>Run the stateful computation within the context `F` and get the value [A](index.html#A). |
| [runS](run-s.html) | `fun runS(MF: Monad<`[`F`](index.html#F)`>, s: `[`S`](index.html#S)`): Kind<`[`F`](index.html#F)`, `[`S`](index.html#S)`>`<br>Run the stateful computation within the context `F` and get the state [S](index.html#S). |
| [transform](transform.html) | `fun <B> transform(FF: Functor<`[`F`](index.html#F)`>, f: (Tuple2<`[`S`](index.html#S)`, `[`A`](index.html#A)`>) -> Tuple2<`[`S`](index.html#S)`, `[`B`](transform.html#B)`>): `[`StateT`](./index.html)`<`[`F`](index.html#F)`, `[`S`](index.html#S)`, `[`B`](transform.html#B)`>`<br>Transform the product of state [S](index.html#S) and value [A](index.html#A) to an another product of state [S](index.html#S) and an arbitrary type [B](transform.html#B). |

### Companion Object Functions

| [get](get.html) | `fun <F, S> get(AF: Applicative<`[`F`](get.html#F)`>): `[`StateT`](./index.html)`<`[`F`](get.html#F)`, `[`S`](get.html#S)`, `[`S`](get.html#S)`>`<br>Return input without modifying it. |
| [inspect](inspect.html) | `fun <F, S, T> inspect(AF: Applicative<`[`F`](inspect.html#F)`>, f: (`[`S`](inspect.html#S)`) -> `[`T`](inspect.html#T)`): `[`StateT`](./index.html)`<`[`F`](inspect.html#F)`, `[`S`](inspect.html#S)`, `[`T`](inspect.html#T)`>`<br>Inspect a value of the state [S](inspect.html#S) with [f](inspect.html#arrow.data.StateT.Companion$inspect(arrow.typeclasses.Applicative((arrow.data.StateT.Companion.inspect.F)), kotlin.Function1((arrow.data.StateT.Companion.inspect.S, arrow.data.StateT.Companion.inspect.T)))/f) `(S) -> T` without modifying the state. |
| [invoke](invoke.html) | `operator fun <F, S, A> invoke(MF: Monad<`[`F`](invoke.html#F)`>, run: `[`StateTFun`](../-state-t-fun.html)`<`[`F`](invoke.html#F)`, `[`S`](invoke.html#S)`, `[`A`](invoke.html#A)`>): `[`StateT`](./index.html)`<`[`F`](invoke.html#F)`, `[`S`](invoke.html#S)`, `[`A`](invoke.html#A)`>`<br>Constructor to create `StateT<F, S, A>` given a [StateTFun](../-state-t-fun.html). |
| [invokeF](invoke-f.html) | `fun <F, S, A> invokeF(runF: `[`StateTFunOf`](../-state-t-fun-of.html)`<`[`F`](invoke-f.html#F)`, `[`S`](invoke-f.html#S)`, `[`A`](invoke-f.html#A)`>): `[`StateT`](./index.html)`<`[`F`](invoke-f.html#F)`, `[`S`](invoke-f.html#S)`, `[`A`](invoke-f.html#A)`>`<br>Alias for constructor [StateT](./index.html). |
| [just](just.html) | `fun <F, S, T> just(MF: Monad<`[`F`](just.html#F)`>, t: `[`T`](just.html#T)`): `[`StateT`](./index.html)`<`[`F`](just.html#F)`, `[`S`](just.html#S)`, `[`T`](just.html#T)`>` |
| [lift](lift.html) | `fun <F, S, A> lift(MF: Monad<`[`F`](lift.html#F)`>, fa: Kind<`[`F`](lift.html#F)`, `[`A`](lift.html#A)`>): `[`StateT`](./index.html)`<`[`F`](lift.html#F)`, `[`S`](lift.html#S)`, `[`A`](lift.html#A)`>`<br>Lift a value of type `A` into `StateT<F, S, A>`. |
| [modify](modify.html) | `fun <F, S> modify(AF: Applicative<`[`F`](modify.html#F)`>, f: (`[`S`](modify.html#S)`) -> `[`S`](modify.html#S)`): `[`StateT`](./index.html)`<`[`F`](modify.html#F)`, `[`S`](modify.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Modify the state with [f](modify.html#arrow.data.StateT.Companion$modify(arrow.typeclasses.Applicative((arrow.data.StateT.Companion.modify.F)), kotlin.Function1((arrow.data.StateT.Companion.modify.S, )))/f) `(S) -> S` and return [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html). |
| [modifyF](modify-f.html) | `fun <F, S> modifyF(AF: Applicative<`[`F`](modify-f.html#F)`>, f: (`[`S`](modify-f.html#S)`) -> Kind<`[`F`](modify-f.html#F)`, `[`S`](modify-f.html#S)`>): `[`StateT`](./index.html)`<`[`F`](modify-f.html#F)`, `[`S`](modify-f.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Modify the state with an [Applicative](#) function [f](modify-f.html#arrow.data.StateT.Companion$modifyF(arrow.typeclasses.Applicative((arrow.data.StateT.Companion.modifyF.F)), kotlin.Function1((arrow.data.StateT.Companion.modifyF.S, arrow.Kind((arrow.data.StateT.Companion.modifyF.F, )))))/f) `(S) -> Kind<F, S>` and return [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html). |
| [set](set.html) | `fun <F, S> set(AF: Applicative<`[`F`](set.html#F)`>, s: `[`S`](set.html#S)`): `[`StateT`](./index.html)`<`[`F`](set.html#F)`, `[`S`](set.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Set the state to a value [s](set.html#arrow.data.StateT.Companion$set(arrow.typeclasses.Applicative((arrow.data.StateT.Companion.set.F)), arrow.data.StateT.Companion.set.S)/s) and return [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html). |
| [setF](set-f.html) | `fun <F, S> setF(AF: Applicative<`[`F`](set-f.html#F)`>, s: Kind<`[`F`](set-f.html#F)`, `[`S`](set-f.html#S)`>): `[`StateT`](./index.html)`<`[`F`](set-f.html#F)`, `[`S`](set-f.html#S)`, `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`>`<br>Set the state to a value [s](set-f.html#arrow.data.StateT.Companion$setF(arrow.typeclasses.Applicative((arrow.data.StateT.Companion.setF.F)), arrow.Kind((arrow.data.StateT.Companion.setF.F, arrow.data.StateT.Companion.setF.S)))/s) of type `Kind<F, S>` and return [Unit](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html). |
| [tailRecM](tail-rec-m.html) | `fun <F, S, A, B> tailRecM(MF: Monad<`[`F`](tail-rec-m.html#F)`>, a: `[`A`](tail-rec-m.html#A)`, f: (`[`A`](tail-rec-m.html#A)`) -> Kind<`[`StateTPartialOf`](../-state-t-partial-of.html)`<`[`F`](tail-rec-m.html#F)`, `[`S`](tail-rec-m.html#S)`>, Either<`[`A`](tail-rec-m.html#A)`, `[`B`](tail-rec-m.html#B)`>>): `[`StateT`](./index.html)`<`[`F`](tail-rec-m.html#F)`, `[`S`](tail-rec-m.html#S)`, `[`B`](tail-rec-m.html#B)`>`<br>Tail recursive function that keeps calling [f](tail-rec-m.html#arrow.data.StateT.Companion$tailRecM(arrow.typeclasses.Monad((arrow.data.StateT.Companion.tailRecM.F)), arrow.data.StateT.Companion.tailRecM.A, kotlin.Function1((arrow.data.StateT.Companion.tailRecM.A, arrow.Kind((arrow.Kind((arrow.Kind((arrow.data.ForStateT, arrow.data.StateT.Companion.tailRecM.F)), arrow.data.StateT.Companion.tailRecM.S)), arrow.core.Either((, arrow.data.StateT.Companion.tailRecM.B)))))))/f)  until [arrow.Either.Right](#) is returned. |

### Extension Functions

| [ap](../arrow.-kind/ap.html) | `fun <E, A, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/ap.html#E)`, `[`A`](../arrow.-kind/ap.html#A)`>.ap(SE: Semigroup<`[`E`](../arrow.-kind/ap.html#E)`>, f: `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/ap.html#E)`, (`[`A`](../arrow.-kind/ap.html#A)`) -> `[`B`](../arrow.-kind/ap.html#B)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/ap.html#E)`, `[`B`](../arrow.-kind/ap.html#B)`>`<br>From Apply: if both the function and this value are Valid, apply the function |
| [combine](../arrow.-kind/combine.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>.combine(SE: Semigroup<`[`E`](../arrow.-kind/combine.html#E)`>, SA: Semigroup<`[`A`](../arrow.-kind/combine.html#A)`>, y: `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/combine.html#E)`, `[`A`](../arrow.-kind/combine.html#A)`>` |
| [combineK](../arrow.-kind/combine-k.html) | `fun <A> `[`ListKOf`](../-list-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`ListKOf`](../-list-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`ListK`](../-list-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`NonEmptyListOf`](../-non-empty-list-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`NonEmptyListOf`](../-non-empty-list-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`NonEmptyList`](../-non-empty-list/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`SequenceK`](../-sequence-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <A> `[`SetKOf`](../-set-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(y: `[`SetKOf`](../-set-k-of.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>): `[`SetK`](../-set-k/index.html)`<`[`A`](../arrow.-kind/combine-k.html#A)`>`<br>`fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>.combineK(SE: Semigroup<`[`E`](../arrow.-kind/combine-k.html#E)`>, y: `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/combine-k.html#E)`, `[`A`](../arrow.-kind/combine-k.html#A)`>` |
| [findValid](../arrow.-kind/find-valid.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>.findValid(SE: Semigroup<`[`E`](../arrow.-kind/find-valid.html#E)`>, that: () -> `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/find-valid.html#E)`, `[`A`](../arrow.-kind/find-valid.html#A)`>`<br>If `this` is valid return `this`, otherwise if `that` is valid return `that`, otherwise combine the failures. This is similar to [orElse](../arrow.-kind/or-else.html) except that here failures are accumulated. |
| [getOrElse](../arrow.-kind/get-or-else.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/get-or-else.html#E)`, `[`B`](../arrow.-kind/get-or-else.html#B)`>.getOrElse(default: () -> `[`B`](../arrow.-kind/get-or-else.html#B)`): `[`B`](../arrow.-kind/get-or-else.html#B)<br>Return the Valid value, or the default if Invalid |
| [handleLeftWith](../arrow.-kind/handle-left-with.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>.handleLeftWith(f: (`[`E`](../arrow.-kind/handle-left-with.html#E)`) -> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/handle-left-with.html#E)`, `[`A`](../arrow.-kind/handle-left-with.html#A)`>` |
| [map](../map.html) | `fun <S, T, P1, R> `[`State`](../-state.html)`<`[`S`](../map.html#S)`, `[`T`](../map.html#T)`>.map(sx: `[`State`](../-state.html)`<`[`S`](../map.html#S)`, `[`P1`](../map.html#P1)`>, f: (`[`T`](../map.html#T)`, `[`P1`](../map.html#P1)`) -> `[`R`](../map.html#R)`): `[`State`](../-state.html)`<`[`S`](../map.html#S)`, `[`R`](../map.html#R)`>`<br>`fun <S, T, R> `[`State`](../-state.html)`<`[`S`](../map.html#S)`, `[`T`](../map.html#T)`>.map(f: (`[`T`](../map.html#T)`) -> `[`R`](../map.html#R)`): `[`State`](../-state.html)`<`[`S`](../map.html#S)`, `[`R`](../map.html#R)`>` |
| [mapFilter](../arrow.-kind/map-filter.html) | `fun <F, A, B> `[`OptionTOf`](../-option-t-of.html)`<`[`F`](../arrow.-kind/map-filter.html#F)`, `[`A`](../arrow.-kind/map-filter.html#A)`>.mapFilter(FF: Functor<`[`F`](../arrow.-kind/map-filter.html#F)`>, f: (`[`A`](../arrow.-kind/map-filter.html#A)`) -> Option<`[`B`](../arrow.-kind/map-filter.html#B)`>): `[`OptionT`](../-option-t/index.html)`<`[`F`](../arrow.-kind/map-filter.html#F)`, `[`B`](../arrow.-kind/map-filter.html#B)`>` |
| [orElse](../arrow.-kind/or-else.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>.orElse(default: () -> `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>): `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/or-else.html#E)`, `[`A`](../arrow.-kind/or-else.html#A)`>`<br>Return this if it is Valid, or else fall back to the given default. The functionality is similar to that of [findValid](../arrow.-kind/find-valid.html) except for failure accumulation, where here only the error on the right is preserved and the error on the left is ignored. |
| [orNull](../arrow.-kind/or-null.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/or-null.html#E)`, `[`B`](../arrow.-kind/or-null.html#B)`>.orNull(): `[`B`](../arrow.-kind/or-null.html#B)`?`<br>Return the Valid value, or null if Invalid |
| [run](../run.html) | `fun <S, A> `[`StateT`](./index.html)`<ForId, `[`S`](../run.html#S)`, `[`A`](../run.html#A)`>.run(initial: `[`S`](../run.html#S)`): Tuple2<`[`S`](../run.html#S)`, `[`A`](../run.html#A)`>`<br>Alias for [StateT.run](run.html) `StateT<ForId, S, A>` |
| [runA](../run-a.html) | `fun <S, A> `[`StateT`](./index.html)`<ForId, `[`S`](../run-a.html#S)`, `[`A`](../run-a.html#A)`>.runA(initial: `[`S`](../run-a.html#S)`): `[`A`](../run-a.html#A)<br>Alias for [StateT.runA](run-a.html) `StateT<ForId, S, A>` |
| [runM](../arrow.-kind/run-m.html) | `fun <F, S, A> `[`StateTOf`](../-state-t-of.html)`<`[`F`](../arrow.-kind/run-m.html#F)`, `[`S`](../arrow.-kind/run-m.html#S)`, `[`A`](../arrow.-kind/run-m.html#A)`>.runM(MF: Monad<`[`F`](../arrow.-kind/run-m.html#F)`>, initial: `[`S`](../arrow.-kind/run-m.html#S)`): Kind<`[`F`](../arrow.-kind/run-m.html#F)`, Tuple2<`[`S`](../arrow.-kind/run-m.html#S)`, `[`A`](../arrow.-kind/run-m.html#A)`>>`<br>Run the stateful computation within the context `F`. |
| [runS](../run-s.html) | `fun <S, A> `[`StateT`](./index.html)`<ForId, `[`S`](../run-s.html#S)`, `[`A`](../run-s.html#A)`>.runS(initial: `[`S`](../run-s.html#S)`): `[`S`](../run-s.html#S)<br>Alias for [StateT.runS](run-s.html) `StateT<ForId, S, A>` |
| [stateT](../arrow.-kind/state-t.html) | `fun <F, S, A> `[`StateTFunOf`](../-state-t-fun-of.html)`<`[`F`](../arrow.-kind/state-t.html#F)`, `[`S`](../arrow.-kind/state-t.html#S)`, `[`A`](../arrow.-kind/state-t.html#A)`>.stateT(): `[`StateT`](./index.html)`<`[`F`](../arrow.-kind/state-t.html#F)`, `[`S`](../arrow.-kind/state-t.html#S)`, `[`A`](../arrow.-kind/state-t.html#A)`>`<br>Wrap the function with [StateT](./index.html). |
| [toIor](../arrow.-kind/to-ior.html) | `fun <E, A> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/to-ior.html#E)`, `[`A`](../arrow.-kind/to-ior.html#A)`>.toIor(): `[`Ior`](../-ior/index.html)`<`[`E`](../arrow.-kind/to-ior.html#E)`, `[`A`](../arrow.-kind/to-ior.html#A)`>`<br>Converts the value to an Ior&lt;E, A&gt; |
| [toList](../arrow.-kind/to-list.html) | `fun <A> `[`SequenceKOf`](../-sequence-k-of.html)`<`[`A`](../arrow.-kind/to-list.html#A)`>.toList(): `[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`A`](../arrow.-kind/to-list.html#A)`>` |
| [traverse](../arrow.-kind/traverse.html) | `fun <G, E, A, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/traverse.html#E)`, `[`A`](../arrow.-kind/traverse.html#A)`>.traverse(GA: Applicative<`[`G`](../arrow.-kind/traverse.html#G)`>, f: (`[`A`](../arrow.-kind/traverse.html#A)`) -> Kind<`[`G`](../arrow.-kind/traverse.html#G)`, `[`B`](../arrow.-kind/traverse.html#B)`>): Kind<`[`G`](../arrow.-kind/traverse.html#G)`, `[`Validated`](../-validated/index.html)`<`[`E`](../arrow.-kind/traverse.html#E)`, `[`B`](../arrow.-kind/traverse.html#B)`>>` |
| [valueOr](../arrow.-kind/value-or.html) | `fun <E, B> `[`ValidatedOf`](../-validated-of.html)`<`[`E`](../arrow.-kind/value-or.html#E)`, `[`B`](../arrow.-kind/value-or.html#B)`>.valueOr(f: (`[`E`](../arrow.-kind/value-or.html#E)`) -> `[`B`](../arrow.-kind/value-or.html#B)`): `[`B`](../arrow.-kind/value-or.html#B)<br>Return the Valid value, or the result of f if Invalid |

