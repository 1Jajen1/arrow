---
title: Fold - arrow-optics
---

[arrow-optics](../../index.html) / [arrow.optics](../index.html) / [Fold](./index.html)

# Fold

`@higherkind interface Fold<S, A> : `[`FoldOf`](../-fold-of.html)`<`[`S`](index.html#S)`, `[`A`](index.html#A)`>`

A [Fold](./index.html) is an optic that allows to focus into structure and get multiple results.

[Fold](./index.html) is a generalisation of an instance of [Foldable](#) and is implemented in terms of foldMap.

### Parameters

`S` - the source of a [Fold](./index.html)

`A` - the target of a [Fold](./index.html)

### Functions

| [choice](choice.html) | `open infix fun <C> choice(other: `[`Fold`](./index.html)`<`[`C`](choice.html#C)`, `[`A`](index.html#A)`>): `[`Fold`](./index.html)`<Either<`[`S`](index.html#S)`, `[`C`](choice.html#C)`>, `[`A`](index.html#A)`>`<br>Join two [Fold](./index.html) with the same target |
| [combineAll](combine-all.html) | `open fun combineAll(M: Monoid<`[`A`](index.html#A)`>, s: `[`S`](index.html#S)`): `[`A`](index.html#A)<br>Alias for fold. |
| [compose](compose.html) | `open infix fun <C> compose(other: `[`Fold`](./index.html)`<`[`A`](index.html#A)`, `[`C`](compose.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](compose.html#C)`>`<br>Compose a [Fold](./index.html) with a [Fold](./index.html)`open infix fun <C> compose(other: `[`Getter`](../-getter/index.html)`<`[`A`](index.html#A)`, `[`C`](compose.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](compose.html#C)`>`<br>Compose a [Fold](./index.html) with a [Getter](../-getter/index.html)`open infix fun <C> compose(other: `[`Optional`](../-optional.html)`<`[`A`](index.html#A)`, `[`C`](compose.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](compose.html#C)`>`<br>Compose a [Fold](./index.html) with a [Optional](../-optional.html)`open infix fun <C> compose(other: `[`Prism`](../-prism.html)`<`[`A`](index.html#A)`, `[`C`](compose.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](compose.html#C)`>`<br>Compose a [Fold](./index.html) with a [Prism](../-prism.html)`open infix fun <C> compose(other: `[`Lens`](../-lens.html)`<`[`A`](index.html#A)`, `[`C`](compose.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](compose.html#C)`>`<br>Compose a [Fold](./index.html) with a [Lens](../-lens.html)`open infix fun <C> compose(other: `[`Iso`](../-iso.html)`<`[`A`](index.html#A)`, `[`C`](compose.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](compose.html#C)`>`<br>Compose a [Fold](./index.html) with a [Iso](../-iso.html)`open infix fun <C> compose(other: `[`Traversal`](../-traversal.html)`<`[`A`](index.html#A)`, `[`C`](compose.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](compose.html#C)`>`<br>Compose a [Fold](./index.html) with a [Traversal](../-traversal.html) |
| [exists](exists.html) | `open fun exists(s: `[`S`](index.html#S)`, p: (`[`A`](index.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check whether at least one element satisfies the predicate. |
| [find](find.html) | `open fun find(s: `[`S`](index.html#S)`, p: (`[`A`](index.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): Option<`[`A`](index.html#A)`>`<br>Find the first element matching the predicate, if one exists. |
| [fold](fold.html) | `open fun fold(M: Monoid<`[`A`](index.html#A)`>, s: `[`S`](index.html#S)`): `[`A`](index.html#A)<br>Fold using the given [Monoid](#) instance. |
| [foldMap](fold-map.html) | `abstract fun <R> foldMap(M: Monoid<`[`R`](fold-map.html#R)`>, s: `[`S`](index.html#S)`, f: (`[`A`](index.html#A)`) -> `[`R`](fold-map.html#R)`): `[`R`](fold-map.html#R)<br>Map each target to a type R and use a Monoid to fold the results |
| [forall](forall.html) | `open fun forall(s: `[`S`](index.html#S)`, p: (`[`A`](index.html#A)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if all targets satisfy the predicate |
| [getAll](get-all.html) | `open fun getAll(s: `[`S`](index.html#S)`): ListK<`[`A`](index.html#A)`>`<br>Get all targets of the [Fold](./index.html) |
| [headOption](head-option.html) | `open fun headOption(s: `[`S`](index.html#S)`): Option<`[`A`](index.html#A)`>`<br>Get the first target |
| [isEmpty](is-empty.html) | `open fun isEmpty(s: `[`S`](index.html#S)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if there is no target |
| [lastOption](last-option.html) | `open fun lastOption(s: `[`S`](index.html#S)`): Option<`[`A`](index.html#A)`>`<br>Get the last target |
| [left](left.html) | `open fun <C> left(): `[`Fold`](./index.html)`<Either<`[`S`](index.html#S)`, `[`C`](left.html#C)`>, Either<`[`A`](index.html#A)`, `[`C`](left.html#C)`>>`<br>Create a sum of the [Fold](./index.html) and a type [C](left.html#C) |
| [nonEmpty](non-empty.html) | `open fun nonEmpty(s: `[`S`](index.html#S)`): `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)<br>Check if there is at least one target |
| [plus](plus.html) | `open operator fun <C> plus(other: `[`Fold`](./index.html)`<`[`A`](index.html#A)`, `[`C`](plus.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](plus.html#C)`>`<br>Plus operator  overload to compose lenses`open operator fun <C> plus(other: `[`Optional`](../-optional.html)`<`[`A`](index.html#A)`, `[`C`](plus.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](plus.html#C)`>`<br>`open operator fun <C> plus(other: `[`Getter`](../-getter/index.html)`<`[`A`](index.html#A)`, `[`C`](plus.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](plus.html#C)`>`<br>`open operator fun <C> plus(other: `[`Prism`](../-prism.html)`<`[`A`](index.html#A)`, `[`C`](plus.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](plus.html#C)`>`<br>`open operator fun <C> plus(other: `[`Lens`](../-lens.html)`<`[`A`](index.html#A)`, `[`C`](plus.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](plus.html#C)`>`<br>`open operator fun <C> plus(other: `[`Iso`](../-iso.html)`<`[`A`](index.html#A)`, `[`C`](plus.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](plus.html#C)`>`<br>`open operator fun <C> plus(other: `[`Traversal`](../-traversal.html)`<`[`A`](index.html#A)`, `[`C`](plus.html#C)`>): `[`Fold`](./index.html)`<`[`S`](index.html#S)`, `[`C`](plus.html#C)`>` |
| [right](right.html) | `open fun <C> right(): `[`Fold`](./index.html)`<Either<`[`C`](right.html#C)`, `[`S`](index.html#S)`>, Either<`[`C`](right.html#C)`, `[`A`](index.html#A)`>>`<br>Create a sum of a type [C](right.html#C) and the [Fold](./index.html) |
| [size](size.html) | `open fun size(s: `[`S`](index.html#S)`): `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>Calculate the number of targets |

### Companion Object Functions

| [codiagonal](codiagonal.html) | `fun <S> codiagonal(): `[`Fold`](./index.html)`<Either<`[`S`](codiagonal.html#S)`, `[`S`](codiagonal.html#S)`>, `[`S`](codiagonal.html#S)`>`<br>[Fold](./index.html) that takes either [S](codiagonal.html#S) or [S](codiagonal.html#S) and strips the choice of [S](codiagonal.html#S). |
| [fromFoldable](from-foldable.html) | `fun <F, S> fromFoldable(foldable: Foldable<`[`F`](from-foldable.html#F)`>): `[`Fold`](./index.html)`<Kind<`[`F`](from-foldable.html#F)`, `[`S`](from-foldable.html#S)`>, `[`S`](from-foldable.html#S)`>`<br>Create a [Fold](./index.html) from a [arrow.Foldable](#) |
| [id](id.html) | `fun <A> id(): `[`Fold`](./index.html)`<`[`A`](id.html#A)`, `[`A`](id.html#A)`>` |
| [select](select.html) | `fun <S> select(p: (`[`S`](select.html#S)`) -> `[`Boolean`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-boolean/index.html)`): `[`Fold`](./index.html)`<`[`S`](select.html#S)`, `[`S`](select.html#S)`>`<br>Creates a [Fold](./index.html) based on a predicate of the source [S](select.html#S) |
| [void](void.html) | `fun <A, B> void(): `[`Fold`](./index.html)`<`[`A`](void.html#A)`, `[`B`](void.html#B)`>`<br>[Fold](./index.html) that points to nothing |

### Extension Properties

| [every](../../arrow.optics.typeclasses/-each/every.html) | `open val <T> `[`Fold`](./index.html)`<`[`T`](../../arrow.optics.typeclasses/-each/every.html#T)`, `[`S`](../../arrow.optics.typeclasses/-each/index.html#S)`>.every: `[`Fold`](./index.html)`<`[`T`](../../arrow.optics.typeclasses/-each/every.html#T)`, `[`A`](../../arrow.optics.typeclasses/-each/index.html#A)`>`<br>DSL to compose [Each](../../arrow.optics.typeclasses/-each/index.html) with a [Fold](./index.html) for a structure [S](../../arrow.optics.typeclasses/-each/index.html#S) to see all its foci [A](../../arrow.optics.typeclasses/-each/index.html#A) |
| [some](../../arrow.optics.dsl/some.html) | `val <T, S> `[`Fold`](./index.html)`<`[`T`](../../arrow.optics.dsl/some.html#T)`, Option<`[`S`](../../arrow.optics.dsl/some.html#S)`>>.some: `[`Fold`](./index.html)`<`[`T`](../../arrow.optics.dsl/some.html#T)`, `[`S`](../../arrow.optics.dsl/some.html#S)`>`<br>DSL to compose a [Prism](../-prism.html) with focus [arrow.core.Some](#) with a [Fold](./index.html) with a focus of [Option](#)&lt;[S](../../arrow.optics.dsl/some.html#S)&gt; |

### Extension Functions

| [at](../../arrow.optics.dsl/at.html) | `fun <T, S, I, A> `[`Fold`](./index.html)`<`[`T`](../../arrow.optics.dsl/at.html#T)`, `[`S`](../../arrow.optics.dsl/at.html#S)`>.at(AT: `[`At`](../../arrow.optics.typeclasses/-at/index.html)`<`[`S`](../../arrow.optics.dsl/at.html#S)`, `[`I`](../../arrow.optics.dsl/at.html#I)`, `[`A`](../../arrow.optics.dsl/at.html#A)`>, i: `[`I`](../../arrow.optics.dsl/at.html#I)`): `[`Fold`](./index.html)`<`[`T`](../../arrow.optics.dsl/at.html#T)`, `[`A`](../../arrow.optics.dsl/at.html#A)`>`<br>DSL to compose [At](../../arrow.optics.typeclasses/-at/index.html) with a [Fold](./index.html) for a structure [S](../../arrow.optics.dsl/at.html#S) to focus in on [A](../../arrow.optics.dsl/at.html#A) at given index [I](../../arrow.optics.dsl/at.html#I). |
| [every](../../arrow.optics.dsl/every.html) | `fun <T, S, A> `[`Fold`](./index.html)`<`[`T`](../../arrow.optics.dsl/every.html#T)`, `[`S`](../../arrow.optics.dsl/every.html#S)`>.every(EA: `[`Each`](../../arrow.optics.typeclasses/-each/index.html)`<`[`S`](../../arrow.optics.dsl/every.html#S)`, `[`A`](../../arrow.optics.dsl/every.html#A)`>): `[`Fold`](./index.html)`<`[`T`](../../arrow.optics.dsl/every.html#T)`, `[`A`](../../arrow.optics.dsl/every.html#A)`>`<br>DSL to compose [Each](../../arrow.optics.typeclasses/-each/index.html) with a [Fold](./index.html) for a structure [S](../../arrow.optics.dsl/every.html#S) to see all its foci [A](../../arrow.optics.dsl/every.html#A) |
| [index](../../arrow.optics.dsl/--index--.html) | `fun <T, S, I, A> `[`Fold`](./index.html)`<`[`T`](../../arrow.optics.dsl/--index--.html#T)`, `[`S`](../../arrow.optics.dsl/--index--.html#S)`>.index(ID: `[`Index`](../../arrow.optics.typeclasses/-index/index.html)`<`[`S`](../../arrow.optics.dsl/--index--.html#S)`, `[`I`](../../arrow.optics.dsl/--index--.html#I)`, `[`A`](../../arrow.optics.dsl/--index--.html#A)`>, i: `[`I`](../../arrow.optics.dsl/--index--.html#I)`): `[`Fold`](./index.html)`<`[`T`](../../arrow.optics.dsl/--index--.html#T)`, `[`A`](../../arrow.optics.dsl/--index--.html#A)`>`<br>DSL to compose [Index](../../arrow.optics.typeclasses/-index/index.html) with a [Fold](./index.html) for a structure [S](../../arrow.optics.dsl/--index--.html#S) to focus in on [A](../../arrow.optics.dsl/--index--.html#A) at given index [I](../../arrow.optics.dsl/--index--.html#I) |

